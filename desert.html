<!DOCTYPE html>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Also Radio</title>
    <style type="text/css">
      #also-radio-wrapper {
          opacity: 0;
          animation: also-radio-fade-in 3s ease-in-out forwards;
          height: 80vw;
          max-height: 85vh;
          position: relative;
      }                                   

      #also-radio-error {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          color: beige;
          background: crimson;
          padding: 12px;
          border-radius: 15px;
          box-sizing: border-box;
          z-index: 999;
          opacity: 0;
          user-select: none;  
          transition: opacity .5s ease;
      }

      .also-radio-error--show {
          opacity: 1 !important;
      }

      @keyframes also-radio-fade-in {
          from {opcity: 0;}
          to {opacity: 1;}
      }

      @keyframes also-radio-fade-in-player {
          from {opcity: 0;}
          to {opacity: 0.8;}
      }
          body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            background: black;
          }

          p {
              font-size: 24px;
              padding: 12px;
              border-radius: 12px;
              margin: 0;
          }

          p:hover {
              cursor: pointer;
          }

          #also-radio-canvas {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border-radius: 24px;          
            z-index: 0;
          }

          #sc-logo {
              position: absolute;
              top: 18px;
              left: 18px;                 
              z-index: 2;
              width: 70px;
          }


          button {
              z-index: 9999;
              outline: none;
              -webkit-appearance: button;
          }

          button:hover {
              cursor: pointer;
          }

          h1 {
              color: white;
              font-size: 69px;
              position: absolute;
              z-index: 1;
          }

          p {
              color: white; 
          }

          #player {
              position: absolute;
              width: 100%;
              bottom: 0px;                  
              left: 50%;
              transform: translateX(-50%);
              z-index: 2;                     

              display: flex;
              flex-direction: column;         
              justify-content: center;        
              align-items: center;            
              opacity: 1;
              transition: opacity 2s ease;
          }

          .player--hidden {
              opacity: 0 !important;
          }

          @media only screen and (max-width: 600px) {
              #also-radio-wrapper {
                  height: 140vw !important;
              }

              #player {
                  width: 100vw !important;
              }

              #player-title {
                  font-size: 16px !important;
              }

              .player-timecode {
                  font-size: 14px !important;
              }
          }

          #player-button {
              width: 90px;
              height: 90px;                   
              border: none;
              background: none;               
              color: white;                   
              margin-bottom: 4px;

              position: relative;
          }                                   

          #player-button svg path {
              fill: white;       
          }

          #player-button #play, #player-button #play--hover, #player-button #pause, #player-button #pause--hover {
              position: absolute;
              top: 0;
              left: 0;             
              transition: opacity .5s ease;
              width: 100%;
              height: 100%;
          }

          #player-button:hover #play, #player-button:hover #pause {
              opacity: 0;
          }

          #player-button #play--hover, #player-button #pause--hover {
              opacity: 0;

              position: absolute;
              top: 0;
              left: 0;

              transition: opacity .5s ease;
          }

          #player-button:hover #play--hover, #player-button:hover #pause--hover {
              opacity: 1;
          }

          .player-button--play #play {
              display: none !important;
          }
          .player-button--play #play--hover {
              display: none !important;
          }

          .player-button--pause #pause {
              display: none !important;
          }
          .player-button--pause #pause--hover {
              display: none !important;
          }

          .player-button--play #pause {                       
              display: inherit;
          }

          .player-button--pause #play {
              display: inherit;
          }

          .player-button--pause #pause {
              display: none;                                 
          }

          #player-info-wrapper{
              width: 80%;                     
          }

          #player-timeline-wrapper{
              width: 100%;                    
              position: relative;                                            
          }

          #player-timeline{
              width: 100%;
              height: 0.5px;                    
              background-color: white;                   
          }

          #player-timeline-playhead {
              width: 10px;
              height: 10px;
              background-color: white;
              border-radius: 50%;             
              position: absolute;
              left: 0%;                      
              bottom: -5px;                       
          }

          #player-timecode-wrapper {
              margin-top: 8px;
              width: 100%;                                                   
              display: flex;                                                 
              justify-content: space-between;                                        
          }

          .player-timecode {
              color: white;                                                  
              font-weight: lighter;
          }

          #player-title-wrapper {
              width: 100%;
              display: flex;
              justify-content: space-between;                          
              align-items: center;
              margin-top: 8px;    

          }

          .player-change {                                             
              background: none;                                        
              margin: 0 -12px 0 -12px;                                               
              padding: 0;
              width: 40px; 
              height: 40px;
              border: none;

          }

          #player-previous #arrow {
              transform: rotate(180deg);
          }

          #player-info {
              width: 60px;
              height: 40px;
              background: none;
              border: none;
              color: white;
              font-size: 13px;    
          }

          #player-info #arrow{
              transform: rotate(90deg);
          }
          #arrow {
              color: white;
              width: 100%;
              height: 100%;
          }

          #player-title {
              color: white;
              font-size: 20px;
          }


          #player-description {
              margin-top: 6px;          
              margin-bottom: 24px;
              width: 80%;                
              font-weight: lighter;      
              color: white;
              font-size: 13px;
              line-height: 1.6;          
              position: relative;
              opacity: 1;
              user-select: none;  
              transition: opacity 1s ease;
          }
                                          
          .player-description--hidden {
              position: absolute !important;
              opacity: 0 !important;                                  
              transition: opacity 0s !important;
          }

          #player-next svg path, #player-previous svg path {
              stroke: white;
              stroke-width: 0;

              transition: stroke-width .5s ease;
          }

          #player-next:hover svg path, #player-previous:hover svg path {
              stroke: white;
              stroke-width: 15;
          }

          #fps {
              color: white;
          }
    </style>
</head>
<body>
  <div id="also-radio-wrapper">
    <audio id="also-radio-audio" crossorigin="anonymous"></audio>
    <div id="also-radio-error">Could not load our mixes. If you are using an adblocker, please concider pausing it for this page and reloading. We do not send tracking info about you to Soundcloud, but your adblocker might still block our connection with Soundcloud.</div>
    <canvas id="also-radio-canvas"></canvas>
    <a href="https://www.soundcloud.com/alsoradio" target="_blank">
    <img src="https://res.cloudinary.com/do4zvxwb9/image/upload/v1603553826/sc_sd8goy.png" id="sc-logo"></img>
    </a>
    <div id="player">
        <button id="player-button" class="player-button--pause">
<svg version="1.1" id="play" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
viewBox="0 0 200 200" xml:space="preserve">
<path class="st0"
d="M100,174.98c-41.43,0-75.14-33.63-75.14-74.98c0-41.34,33.71-74.98,75.14-74.98s75.14,33.63,75.14,74.98 C175.14,141.34,141.43,174.98,100,174.98z M100,27.02c-40.33,0-73.14,32.74-73.14,72.98s32.81,72.98,73.14,72.98 c40.33,0,73.14-32.74,73.14-72.98S140.33,27.02,100,27.02z M79.88,130.66V69.34L133.11,100L79.88,130.66z M81.88,72.8v54.41 L129.1,100L81.88,72.8z" />
</svg>

<svg version="1.1" id="play--hover" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
viewBox="0 0 200 200" xml:space="preserve">
<path class="st0"
d="M100,26.35c-40.77,0-73.81,32.97-73.81,73.65s33.05,73.65,73.81,73.65s73.81-32.97,73.81-73.65 S140.77,26.35,100,26.35z M80.96,128.81V71.19l50,28.81L80.96,128.81z" />
</svg>

<svg version="1.1" id="pause" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
viewBox="0 0 200 200" xml:space="preserve">

<path class="st0"
d="M100,174.97c-41.46,0-75.19-33.63-75.19-74.97c0-41.34,33.73-74.97,75.19-74.97s75.19,33.63,75.19,74.97 C175.19,141.34,141.46,174.97,100,174.97z M100,27.03c-40.36,0-73.19,32.73-73.19,72.97c0,40.24,32.83,72.97,73.19,72.97 s73.19-32.73,73.19-72.97C173.19,59.77,140.36,27.03,100,27.03z M134.23,139.89h-25.12V60.11h25.12V139.89z M111.11,137.89h21.12 V62.11h-21.12V137.89z M90.89,139.89H65.77V60.11h25.12V139.89z M67.77,137.89h21.12V62.11H67.77V137.89z" />
</svg>

<svg version="1.1" id="pause--hover" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
viewBox="0 0 200 200" xml:space="preserve">
<path class="st0"
d="M100,26.03c-40.98,0-74.19,33.12-74.19,73.97s33.22,73.97,74.19,73.97s74.19-33.12,74.19-73.97 S140.98,26.03,100,26.03z M89.89,138.89H66.77V61.11h23.11V138.89z M133.23,138.89h-23.11V61.11h23.11V138.89z" />
</svg>
        </button>
        <div id="player-info-wrapper">
            <div id="player-timeline-wrapper">
                <div id="player-timeline"></div>
                <div id="player-timeline-playhead"></div>
            </div>
            <div id="player-timecode-wrapper">
                <div id="player-timecode--left" class="player-timecode">00:00</div>
                <div id="player-timecode--right" class="player-timecode">00:00</div>
            </div>
            <div id="player-title-wrapper">
                <button id="player-previous" class="player-change">
<svg version="1.1" id="arrow" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
viewBox="0 0 86.24 86.24" xml:space="preserve">

<path fill="white" class="st0"
d="M29,60.01V26.23l29.25,16.89L29,60.01z M31,29.7v26.85l23.25-13.42L31,29.7z" />
</svg>
                </button>
                <div id="player-title"></div>
                <button id="player-next" class="player-change">
<svg version="1.1" id="arrow" xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
viewBox="0 0 86.24 86.24" xml:space="preserve">

<path fill="white" class="st0"
d="M29,60.01V26.23l29.25,16.89L29,60.01z M31,29.7v26.85l23.25-13.42L31,29.7z" />
</svg>
                </button>
            </div>
        </div>
        <button id="player-info">˅ info</button>
        <div id="player-description" class="player-description--hidden"></div>
    </div>
    <div id="fps"></div>
    </div>
    <script type="text/javascript" src=
    "https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
    </script>
    <script type="glsl" id="FSHADER_SOURCE">
        #define DAY        

        precision highp float;
        uniform float u_time;
        uniform float u_currentTime;
        uniform vec2 u_resolution;
        uniform sampler2D u_texture;

        uniform float u_bass;
        uniform float u_mid;
        uniform float u_high;

        uniform float u_tod; // time of day mix from 0 -> 1
        uniform float u_distort; // mix in field distortion effect

        uniform float u_distort_2;
        uniform float u_distort_3;
        uniform float u_distort_4;

        uniform float u_ballSpeed;
        uniform float u_playing;

        vec3 _CameraPosition = vec3(0.0, 0.6, 0.0);

        /* COLORS */

        // Day
        vec3 _SkyTopColor_0 = vec3(0.18, 0.55, 1.0);
        vec3 _SkyBottomColor_0 = vec3(0.95, 0.95, 0.9);
        vec3 _SunColor_0 = vec3(5.4, 3.1, 2.0);
        vec3 _SkyColor_0 = vec3(0.5, 0.6, 0.9);
        vec3 _BounceColor_0 = vec3(0.6, 0.1, 0.1);
        vec3 _GlitterColor_0 = vec3(0.5, 0.5, 0.3);
        vec3 _OceanColor_0 = vec3(10.0, 10.0, 5.0);
        vec3 _DistanceColor_0 = vec3(0.3, 0.3, 0.35);
        vec3 _SphereSpecColor_0 = vec3(3.0, 3.0, 2.0);
        vec3 _FresnelColor_0 = vec3(1.0, 0.5, 0.5);

        // Night
        vec3 _SkyTopColor_1 = vec3(0.00, 0.00, 0.01);
        vec3 _SkyBottomColor_1 = vec3(0.01, 0.01, 0.02);
        vec3 _SunColor_1 = vec3(0.1, 0.2, 0.6);
        vec3 _SkyColor_1 = vec3(0.0, 0.0, 0.1);
        vec3 _BounceColor_1 = vec3(0.04, 0.0, 0.0);
        vec3 _GlitterColor_1 = vec3(0.2, 0.1, 0.2);
        vec3 _OceanColor_1 = vec3(1.9, 0.9, 0.9);
        vec3 _DistanceColor_1 = vec3(0.03, 0.03, 0.05);
        vec3 _SphereSpecColor_1 = vec3(0.5, 0.2, 0.5);
        vec3 _FresnelColor_1 = vec3(0.15, 0.05, 0.05);

        vec3 _SkyTopColor = mix(_SkyTopColor_0, _SkyTopColor_1, u_tod);
        vec3 _SkyBottomColor =  mix(_SkyBottomColor_0, _SkyBottomColor_1, u_tod);
        vec3 _SunColor = mix(_SunColor_0, _SunColor_1, u_tod);
        vec3 _SkyColor = mix(_SkyColor_0, _SkyColor_1, u_tod);
        vec3 _BounceColor = mix(_BounceColor_0, _BounceColor_1, u_tod);
        vec3 _GlitterColor = mix(_GlitterColor_0, _GlitterColor_1, u_tod);
        vec3 _OceanColor = mix(_OceanColor_0, _OceanColor_1, u_tod);
        vec3 _DistanceColor = mix(_DistanceColor_0, _DistanceColor_1, u_tod);
        vec3 _SphereSpecColor = mix(_SphereSpecColor_0, _SphereSpecColor_1, u_tod);
        vec3 _FresnelColor = mix(_FresnelColor_0, _FresnelColor_1, u_tod);

        vec3 _SandColor = vec3(0.18, 0.16, 0.13);

        vec3 _SphereColor_Black = vec3(0.002, 0.001, 0.004);
        vec3 _SphereColor = vec3(0.2, 0.1, 0.4);

        // Simplex 2D noise
        vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

        float snoise(vec2 v){
            const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                    -0.577350269189626, 0.024390243902439);
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
            + i.x + vec3(0.0, i1.x, 1.0 ));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                dot(x12.zw,x12.zw)), 0.0);
            m = m*m ;
            m = m*m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
            vec3 g;
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

      // Fast noise
      float hash21(vec2 p) {
          p = fract(p*vec2(123.34, 456.21));
          p += dot(p, p+45.32);
          return fract(p.x * p.y);
      }


        // NVIDIA Sine wave approximation
        float smoothCurve( float x, float smoothingFactor ) {
            return x * x *( (3.0 - smoothingFactor) - (2.0 - smoothingFactor) * x );
        }

        float triangleWave( float x ) {
            return abs( fract( x + 0.5 ) * 2.0 - 1.0 );
        }

        float sharpTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.5 );
        }

        float smoothTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.0 );
        } 

        float smin( float a, float b, float k ) {
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            return mix( b, a, h ) - k*h*(1.0-h);
        }

        // SD Functions
        // 
        // Desert plane
        float sdDesert(vec3 pos)
        {
            float amp = u_bass / 3.;

            float fh = -1.0 + (0.6 + amp) * (sharpTriangleWave(-0.2 + (0.1*pos.x) + 0.17*smoothTriangleWave(pos.x*0.1) + 0.3*smoothTriangleWave(pos.x*0.02)) + smoothTriangleWave(0.06*pos.z + 0.01*smoothTriangleWave(pos.z*0.2)));
            fh += pow(abs(fh), 1.7);

            float hf = smoothTriangleWave(3.6*(pos.z + 0.02*smoothTriangleWave((pos.x + (u_time * 0.9)) * 2.6))); //+ smoothTriangleWave(20.*pos.y);
            float hf2 = smoothTriangleWave(2.*pos.x + (u_time * 1.));

            float d = pos.y - (fh + ((0.138*(u_high*2.4))* hf * (clamp(-pos.y + 0.2, 0., 1.))) + (0.0026 * hf2 * (pos.y)));

            return d;
        }

        float sdSphere(vec3 pos, float radius) {

            float z = -4.5- (mod(u_currentTime, 16.5) - (u_mid * 1.0));
            float y = -0.1 + ((0.6 + (smoothTriangleWave(u_time * 0.1)) ) * 0.7);
            vec3 cen = vec3(mix(-0.3, 0.3, smoothTriangleWave(u_time * 0.015)), y, z);
                         
            return length(pos - cen) - (radius + (u_mid/ 6.));
        }

        float sdMetaballs(vec3 pos, vec3 mb_p_2, vec3 mb_p_3) {
             // Floating spheres
            float result = sdSphere(pos, 0.5);                            

            vec3 pos_2 = vec3(pos.x + mb_p_2.x, pos.y - mb_p_2.y, pos.z + mb_p_2.z);
            vec3 pos_3 = vec3(pos.x + mb_p_3.x, pos.y + mb_p_3.y, pos.z + mb_p_3.z);

            float ball_2 = sdSphere(pos_2, 0.4);
            float ball_3 = sdSphere(pos_3, 0.3);

            result = smin(result, ball_2, 0.5);
            result = smin(result, ball_3, 0.5);           

            return result;
        }

      vec2 map(vec3 pos, vec3 mb_p_2, vec3 mb_p_3) {
            float d = -1.0;

            // Metaballs
            vec3 ball_pos = pos;
            ball_pos.x = mod(abs(ball_pos.x), 5.0) - 1.5;
            ball_pos.z += 0.3 * (((smoothTriangleWave(abs(ball_pos.z * 0.5)) + 1.) / 2.) - 0.5);


            float d1 = sdMetaballs(mix(pos, ball_pos, u_distort), mb_p_2, mb_p_3);
                                                                     
            // Ground
            float d2 = sdDesert(pos);

            // Combine
            d = smin(d1, d2, 0.5);

            if (d1 < d2) {
                return vec2(d, 1.7);
            } else {
                return vec2(d, 1.0);
            }
        }

        
        float calcOcclusion(vec3 pos, vec3 nor, vec3 mb_p_2, vec3 mb_p_3)
        {
            float occ = 0.0;
            float sca = 1.0;
            for( int i=0; i<5; i++ )
            {
                float h = 0.01 + 0.11*float(i)/4.0;
                vec3 opos = pos + h*nor;
                float d = map(opos, mb_p_2, mb_p_3).x;
                occ += (h-d)*sca;
                sca *= 0.95;
            }
            return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );
        }

      vec3 calcNormal(vec3 pos, vec3 mb_p_2, vec3 mb_p_3) {
            vec2 e = vec2(0.0001, 0.0);
          return normalize( vec3( map(pos+e.xyy, mb_p_2, mb_p_3).x-map(pos-e.xyy, mb_p_2, mb_p_3).x,
                                  map(pos+e.yxy, mb_p_2, mb_p_3).x-map(pos-e.yxy, mb_p_2, mb_p_3).x,
                                  map(pos+e.yyx, mb_p_2, mb_p_3).x-map(pos-e.yyx, mb_p_2, mb_p_3).x));
        }

        vec2 textureMapping(vec3 pos) {
            return pos.xz*vec2(0.03,0.07);
        }

        vec2 castRay(vec3 ro, vec3 rd, vec3 mb_p_2, vec3 mb_p_3) {
            vec2 res = vec2(-1.0, -1.0);
            float tmin = 0.5;
            float tmax = 30.0;

            float t = tmin;

            for (int i = 0; i < 450; i++) {
                vec2 h = map(ro+rd*t, mb_p_2, mb_p_3);
                if (abs(h.x) < 0.015) {
                    res = vec2(t, h.y);
                    break;
                }
                t += h.x;

                if (t>tmax) {
                    break;
                }
                
            }

            return res;
        }

        float castShadow(vec3 ro, vec3 rd, vec3 mb_p_2, vec3 mb_p_3) {
            float res = 1.0;

            float t = 0.001;
            for (int i = 0; i < 70; i++) {
                vec3 pos = ro + t*rd;
                float h = map(pos, mb_p_2, mb_p_3).x;

                res = min( res, 16.0*h / t );

                if ( h < 0.0005 ) break;

                t += h;

                if (t > 20.0) break;
            }

            return res;
        }


        vec3 nlerp(vec3 n1, vec3 n2, float t){
            return normalize(mix(n1, n2, t));
        }


        float diffuse(vec3 n, vec3 l) {
            n.y *= 0.3;
            float nDotL = clamp(4. * dot(n, l), 0.0, 1.0);
            return nDotL;
        }

        float rim(vec3 n, vec3 v) {
            float rim = 1.0 - clamp(dot(n, v), 0.0, 1.0);
            rim = clamp(pow(rim, 60.3) * 0.9, 0.0, 1.0);
            return rim;
        }

        float oceanSpecular(vec3 n, vec3 l, vec3 v) {
            // Blinn-Phong
            vec3 h = normalize(v + l); // Half direction
            float NdotH = max(0., dot(n, h));
            float specular = pow(NdotH, 600.0) * 2.7;
            return specular;
        }

        float glitterSpecular(vec2 uv, vec3 l, vec3 v, float threshold, vec3 noise) {

            vec3 R = reflect(l, noise);

            float rDotV = max(0.0, dot(R, v));

            if (rDotV < threshold) {
                return 0.0;
            }
            return rDotV;
        }

        vec3 sandNormal(vec2 uv, vec3 n) {
            float noise = hash21(uv * 1000.);
            vec3 random = vec3(noise, fract(noise * 10.), fract(noise * 20.));
            vec3 s = normalize(random);

            vec3 Ns = nlerp(n, s, 0.08);
            return Ns;
        }

        vec4 blur(sampler2D image, vec2 uv) {
            const float Pi = 6.28318530718; // Pi*2
    
            // GAUSSIAN BLUR SETTINGS {{{
            const float Directions = 12.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)
            const float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)
            const float Size = 12.0; // BLUR SIZE (Radius)
            // GAUSSIAN BLUR SETTINGS }}}

            vec2 Radius = Size/u_resolution.xy;

            // Pixel colour
            vec4 Color = texture2D(image, uv);

            // Blur calculations
            for( float d=0.0; d<Pi; d+=Pi/Directions)
            {
                for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)
                {
                    Color += texture2D(image, uv+vec2(cos(d),((smoothTriangleWave(d * 0.2) * 2.0) - 1.))*Radius*i);
                }
            }

            // Output to screen
            Color /= Quality * Directions - 15.0;

            return Color;
        }

        vec3 fresnelSchlick(vec3 N, vec3 I){
            vec3 F0 = vec3(0.0);
            return F0 + (1.0 - F0) * pow(1.0 - (dot(N, I)), 5.0);
        }

        vec3 starColor(vec2 uv) {
            vec2 star_uv = uv  * 12.;
            vec2 star_gv = fract(star_uv) - .5;
            vec2 star_id = floor(star_uv);

            float star_noise = hash21(star_id);
            float star_distance = length(vec2(star_gv.x + ((star_noise - .5)), star_gv.y + (fract(star_noise * 94.281)-.5))) * 7.;
            float star_strength = smoothstep(.15, .05, star_distance);
            float star_glow = smoothstep(2.35, .005, star_distance);

            return vec3(star_strength*((star_noise * .1) + (u_mid * 0.8))) + (0.0015 * vec3(star_glow)) * vec3(star_noise);
        }

        vec3 logoColor(vec2 uv) {
            vec2 logo_uv = uv * 1.8;                          
            logo_uv.x += 0.5;
            logo_uv.y += 0.36; 

            vec3 logo_hue = vec3(1.2, 1.0, 1.0);

            vec3 logo_blur = clamp(blur(u_texture, logo_uv), 0., 1.).rgb;
            vec3 logo = clamp(texture2D(u_texture, logo_uv), 0., 1.).rgb;

            return clamp(logo * (0.05 + u_bass) + (logo_blur * (u_bass * 0.4)), 0.0 , 1.0) * logo_hue;
        }

        vec3 moonColor(vec2 uv, float pos_sin) {              
            vec2 moon_uv = uv;
            moon_uv.x += 0.02 - (0.1 * pos_sin);              
            float d = length(moon_uv);
            float m = .01 / d;

            return min(m, 0.9) * vec3(0.2 + (u_mid * 0.6), 0.2, 0.4);   
        }

        void main() {
            vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            // Reset camera position every 16.5s to avoid unstable ray marching with large numbers
            _CameraPosition.z -= mod(u_currentTime, 16.5);
            //_CameraPosition.z -= u_time * u_playing;

            // Camera target
            vec3 ta = _CameraPosition - vec3(0., 0.5, 800.);
            // Ray origin
            vec3 ro = _CameraPosition;

            // Camera vectors
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));
            vec3 vv = normalize(cross(uu,ww));

            // Ray direction
            float fov = 1.6;
            vec3 rd = normalize(p.x * uu + p.y * vv + fov * ww);

            // Color = sky gradient to start, then more stuff is added as we
            // march through our scene
            vec3 col = mix(_SkyTopColor, _SkyBottomColor, exp(-10.0*rd.y));

            // Render sky
            vec2 sky_uv = (gl_FragCoord.xy-0.5*u_resolution.xy) / u_resolution.y;
            col += starColor(sky_uv);                         
            col += logoColor(sky_uv);                         

            float sun_pos_wave = (smoothTriangleWave(u_time * 0.1) * 2.) - 1.; // Used to animate sun/moon position
            col += moonColor(sky_uv, sun_pos_wave);           

            // Metaball positions
            // We only want to calculate these once, not every time we call map
            vec3 mb_p_2 = vec3((0.2 * u_mid * ((smoothTriangleWave(u_time * 0.5) * 2.) - 1.)) + ((smoothTriangleWave(u_time * (0.05 * u_ballSpeed)) * 2.) - 1.), (0.2* u_bass) * smoothTriangleWave(u_time * 0.4) -(0.3 * ((smoothTriangleWave(u_time * (0.033 * u_ballSpeed)) * 2.) - 1.)), ( 0.8 * cos(u_time * (0.5 * u_ballSpeed))));
            vec3 mb_p_3 = vec3((0.1 * u_mid * ((smoothTriangleWave(u_time * 0.6) * 2.) - 1.)) - ((smoothTriangleWave(u_time * (0.01 * u_ballSpeed)) * 2.) - 1.), (0.3* u_bass) * smoothTriangleWave(u_time * 0.05) - (0.5 * ((smoothTriangleWave(u_time * (0.08 * u_ballSpeed)) * 2.) - 1.)), ( 0.8 * cos(u_time * (0.5 * u_ballSpeed))));


            // We don't need to raymarch the sky
            vec2 tm = castRay(ro, rd, mb_p_2, mb_p_3);                        

            if (tm.y > 0.0) {
                float t = tm.x;
                vec3 pos = ro + t*rd;
                vec3 nor = calcNormal(pos, mb_p_2, mb_p_3);
                vec2 uv = fract(textureMapping(pos) * 4.);

                vec3 sand_nor = sandNormal(uv, nor);

                // Lights
                vec3 ocean_light = normalize(vec3(0., 2., -3.));
                vec3 sun_dir = normalize(vec3(0. + 4.* sun_pos_wave, 5.6, -3.2));

                // Lighting calculations
                float occ = calcOcclusion(pos, sand_nor, mb_p_2, mb_p_3);
                float sun_sha = clamp(castShadow(pos+sand_nor*0.01, sun_dir, mb_p_2, mb_p_3), 0.0 ,1.0);
                float sky_dif = 0.9 * diffuse(sand_nor, vec3(0.0, 1.0, 0.0));
                float bounce_dif = clamp(0.5 + 0.3*dot(sand_nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);
                float sun_dif = diffuse(sand_nor, sun_dir);
                float rim = rim(sand_nor, -rd);
                float oceanSpec = oceanSpecular(sand_nor, ocean_light, -rd) / (t/ 2.);
                float spec = max(rim, oceanSpec) / (t);

                vec3 glitterNoise = vec3(snoise(uv*300.), snoise(uv*400.), snoise(uv*440.));
                float glitterSpec = glitterSpecular(uv, sun_dir, -rd, 0.9, glitterNoise) / (t/ 1.5);
                float glitterSpecLots = glitterSpecular(uv, sun_dir, -rd, 0.2, glitterNoise) / (t/2.);

                vec3 mate = _SandColor;
                if (tm.y > 1.5) {
                    vec3 sphereColor = mix(_SphereColor, _SphereColor_Black, u_distort_4);
                    mate = sphereColor;
                }

                // Light color
                vec3 li = vec3(0.0);
                li += sun_dif * _SunColor * sun_sha * occ;
                li += sky_dif * _SkyColor * occ;
                li += bounce_dif * _BounceColor * occ;

                // Material color
                col = li * mate;
                if (tm.y < 1.5) { // Sand
                    _GlitterColor = vec3(_GlitterColor.r + (u_mid * 0.8), _GlitterColor.g, _GlitterColor.b + (u_mid * 0.3));
                    _OceanColor = vec3(_OceanColor.r + (u_mid * 0.4), _OceanColor.g, _OceanColor.b + (u_mid * 0.1));
                    col += (glitterSpec * sun_dif * _GlitterColor * sun_sha);
                    col += (spec * glitterSpecLots * _OceanColor * sun_sha);
                } else { // Sphere
                    vec3 fresnel = fresnelSchlick(sand_nor, -rd);
                    col += _SphereSpecColor * spec;
                    col += fresnel * _FresnelColor;
                }

                // Distance fog
                float distance = clamp((t-15.) / 20., 0.0, 1.0);
                col = mix(col, _DistanceColor, distance);      
            }

            col = pow( col, vec3(0.4545) );

            col.b = mix(col.b, 0.4 - col.r, u_distort_2 * (u_bass * 0.7));
            col.g = mix(col.g, 0.1 - col.g, u_distort_3 * (u_bass * 0.7));

            gl_FragColor = vec4(col, 1.0);
        }
    </script>
    <script type="text/javascript">
      window.addEventListener('load', (event) => {
      const BALL_ACC = 0.01;
      const BALL_SPEED_NORMAL = 0.7;
      const BALL_SPEED_FAST = 1.8;
      const INFO_URL = "https://api.soundcloud.com/users/287905929/tracks?client_id=9e05e349251475056d1bc81acbf08c71&secret_token=track";

      const fs = document.getElementById("FSHADER_SOURCE").textContent;
      const canvas = document.getElementById("also-radio-canvas");
      canvas.width = canvas.clientWidth * 2;
      canvas.height = canvas.clientHeight * 2;
      const glslCanvas = new GlslCanvas(canvas);
      glslCanvas.load(fs);

      let tracks = [];
      let selectedTrack = 0;
      let isPlaying = false;
      let isStopped = true;
      let showingInfo = false;             

      // Audio setup
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      const audioContext = new AudioCtx();
      const analyser = audioContext.createAnalyser();
      const audioElement = document.getElementById("also-radio-audio");
      const audioSource = audioContext.createMediaElementSource(audioElement);
      audioSource.connect(analyser);      
      analyser.connect(audioContext.destination);       
      analyser.fftSize = 1024;
      const bufferLength = analyser.frequencyBinCount;
      let dataArray = new Uint8Array(bufferLength);

      // Animation variables
      let ballSpeed = 0.2;
      let isDistorting = false;
      let isDistorting2 = 0.0;
      let isDistorting3 = 0.0;
      let isDistorting4 = 0.0;

      let lastTime = 0.0;
      let timestamp = 0.0;
      let startCurrentTime = 0.0;
      let currentTime = 0.0;

      // mouse move stuff
      let timeout;
      let hideControls = false;

      const setUniform = (name, value) => {
          try {
              glslCanvas.setUniform(name, value);
          } catch (e) {}
      }

      const getFormattedNumber = duration => {              
          const minutes = Math.floor(duration / 60);
          const seconds = Math.floor(duration - minutes * 60);
          const formattedMinutes = ("0" + minutes).slice(-2);
          const formattedSeconds = ("0" + seconds).slice(-2);
          return `${formattedMinutes}:${formattedSeconds}`;
      }

      const updateUIInfo = () => {
          const track = tracks[selectedTrack];
          document.getElementById("player-title").innerHTML = track.title;
          document.getElementById("player-timecode--right").innerHTML = getFormattedNumber(track.duration / 1000);
          document.getElementById("player-description").innerHTML = track.description;
          if (hideControls) {
              document.getElementById("player").classList.add("player--hidden");
          } else {
              document.getElementById("player").classList.remove("player--hidden");
          }
      }

      const updatePlayerButton = () => {
          const buttonElement = document.getElementById("player-button");
          if (isPlaying) {
              buttonElement.classList.add("player-button--play");
              buttonElement.classList.remove("player-button--pause");
          } else {
              buttonElement.classList.add("player-button--pause");
              buttonElement.classList.remove("player-button--play");               
          }
      }

      const fetchTrackInfo = async () => {
          const response = await fetch(INFO_URL);

          if (!response.ok) {
              document.getElementById("also-radio-error").classList.add("also-radio-error--show");
              return;
          }

          const data = await response.json();

          console.log("got the data");

          tracks = await Promise.all(data.map(async track => {
              const streamsResponse = await fetch(getStreamsUrl(track.id));
              const streamsData = await streamsResponse.json();

              const t = {
                  id: track.id,
                  title: track.title,
                  description: track.description,
                  duration: track.duration,
                  streamUrl: streamsData.http_mp3_128_url,
              }

              return t;
          }));

          updateUIInfo();
      }

      const getStreamsUrl = (trackId) => (
  `https://api.soundcloud.com/tracks/${trackId}/streams?client_id=9e05e349251475056d1bc81acbf08c71`
      );

       const play = (pausedAt) => {
          startCurrentTime = timestamp;
          if (isPlaying) {           
              pause()
              return;
          }

          if (tracks[selectedTrack]) {
              audioElement.src = tracks[selectedTrack].streamUrl;
              audioContext.resume();
              if (pausedAt) {        
                  audioElement.currentTime = pausedAt;
              }
              audioElement.play();               
              isPlaying = true;
              isStopped = false;
          }
          updatePlayerButton();
          setUniform("u_playing", 1);
      }

      const pause = (stop) => {
          if (tracks[selectedTrack]) {
              audioElement.pause();  
              isPlaying = false;
          }
          updatePlayerButton();
          setUniform("u_playing", 0);
      }

      const stop = () => {
          audioElement.pause();
          audioElement.currentTime = 0;
          isStopped = true;          
          isPlaying = false;         
          updatePlayerButton();                             
          setUniform("u_playing", 0);
      }

      const handleNextTrackClick = () => {
          selectedTrack += 1;

          if (selectedTrack >= tracks.length) {
              selectedTrack = tracks.length - 1;
          }
          stop();
          updateUIInfo();            
      }

      const handlePreviousTrackClick = (trackIndex) => {
          selectedTrack -= 1;        

          if (selectedTrack < 0) {
              selectedTrack = 0;
          }
          stop();
          updateUIInfo();
      }

      const handleInfoClick = () => {
          const descriptionElement = document.getElementById("player-description");
          const buttonElement = document.getElementById("player-info");
          if (showingInfo) {
              descriptionElement.classList.add("player-description--hidden")
              buttonElement.innerHTML = "˅ info"
              showingInfo = false;
          } else {
              descriptionElement.classList.remove("player-description--hidden")
              buttonElement.innerHTML = "˄ info"
              showingInfo = true; 
          }
      }

      function throttled(delay, fn) {
          let lastCall = 0;
          return function (...args) {
              const now = (new Date).getTime();
              if (now - lastCall < delay) {
                  return;
              }
              lastCall = now;
              return fn(...args);
          }
      }

      const handleMouseMove = () => {
          if (timeout) {
              window.clearTimeout(timeout);
          }

          timeout = window.setTimeout(() => {
              if (isPlaying) {
                  hideControls = true;
                  updateUIInfo();
              }
          }, 3000);

          if (hideControls) {
              hideControls = false;
              updateUIInfo();
          }
      }

      const registerEventHandlers = () => {
          document.getElementById("player-button").onclick = () => {
              audioContext.resume();
              if (isStopped) {
                  play()
              } else {
                  play(audioElement.currentTime);
              }
          };
          document.getElementById("player-next").onclick = handleNextTrackClick;
          document.getElementById("player-previous").onclick = handlePreviousTrackClick;
          document.getElementById("player-info").onclick = handleInfoClick;             

          window.addEventListener("mousemove", throttled(200, handleMouseMove));
      }

      const setInitialUniformValues = () => {
          setUniform("u_texture","https://res.cloudinary.com/do4zvxwb9/image/upload/v1603553822/logo_k9gbdp.jpg")
          setUniform("u_ballSpeed", ballSpeed);             
          setUniform("u_tod", 1);
          setUniform("u_playing", 0);
      }

      const updateUniforms = () => {
          // Audio analyzer uniforms
          analyser.getByteFrequencyData(dataArray);

          const bass = dataArray.slice(0, 4).reduce((acc, e) => acc+e) / 4;
          const mid = dataArray.slice(100, 300).reduce((acc, e) => acc+e) / 199;
          const high = dataArray.slice(300, 500).reduce((acc, e) => acc+e) / 199;

          setUniform("u_bass", bass / 255);
          setUniform("u_mid", mid / 255);
          setUniform("u_high", high / 255);
          setUniform("u_distort", audioElement.currentTime % 20 > 15 ? 1 : 0);         

          setUniform("u_distort", isDistorting);
          setUniform("u_distort_2", isDistorting2);
          setUniform("u_distort_3", isDistorting3);
          setUniform("u_distort_4", isDistorting4);

          setUniform("u_ballSpeed", ballSpeed);
          setUniform("u_currentTime", currentTime);

          // Time of day
          if (audioElement.currentTime && audioElement.duration) {
              // From night to day to night again
              const progress = 1 - (audioElement.currentTime / audioElement.duration);
              let tod = 0;
              if (progress > 0.5) {
                  tod = Math.min(1., progress * 1.2);
              } else {
                  tod = Math.min(1., 1 - (progress * 1.2));
              }
              setUniform("u_tod", tod);
          }
      }

      const updateAnimationVariables = (timestamp) => {
          // We need a higher resolution currentTime
          // than audioElement.currentTime for smooth animations
          if (isPlaying) {
              currentTime = (timestamp - startCurrentTime) / 1000;
          }

          // Start animation
          if (isPlaying && ballSpeed < BALL_SPEED_NORMAL) {
              ballSpeed += BALL_ACC;
              if (ballSpeed > BALL_SPEED_NORMAL) {
                  ballSpeed = BALL_SPEED_NORMAL;
              }
          }

          if (isPlaying && !isDistorting && ballSpeed > BALL_SPEED_NORMAL) {
              ballSpeed = BALL_SPEED_NORMAL;
          }

          // Distortion animation
          if (isPlaying && audioElement.currentTime % 25 > 16) {
              ballSpeed = BALL_SPEED_FAST;
              isDistorting = true;
          } else {
              isDistorting = false;
          }

          if (isPlaying && audioElement.currentTime % 180 > 160) {
              isDistorting2 += 0.01;
              if (isDistorting2 >= 1) {
                  isDistorting2 = 1
              }
          } else {
              isDistorting2 -= 0.01;
              if (isDistorting2 <= 0) {
                  isDistorting2 = 0
              }
          }

          if (isPlaying && audioElement.currentTime % 230 > 210) {
              isDistorting3 += 0.01;
              if (isDistorting3 >= 1) {
                  isDistorting3 = 1
              }
          } else {
              isDistorting3 -= 0.01;
              if (isDistorting3 <= 0) {
                  isDistorting3 = 0
              }
          }
          const songProgress = (audioElement.currentTime / audioElement.duration);
          if (songProgress > 0.43 && songProgress < 0.58 && isPlaying) {
              isDistorting4 += 0.006;
              if (isDistorting4 >= 1) {
                  isDistorting4 = 1
              }
          } else {
              isDistorting4 -= 0.006;
              if (isDistorting4 <= 0) {
                  isDistorting4  = 0
              }
          }
          updateUniforms();         
      }

      function update(timestamp){
          timestamp = timestamp;

     
          updateAnimationVariables(timestamp);

          const fps = 1 / ((timestamp - lastTime) / 1000);
          document.getElementById("fps").innerHTML = fps;

          lastTime = timestamp;

          // Update HTML
          document.getElementById("player-timecode--left").innerHTML = getFormattedNumber(audioElement.currentTime);
          const percentage = (audioElement.currentTime / audioElement.duration) * 100;
          document.getElementById("player-timeline-playhead").style.left = `${percentage}%`;
          window.requestAnimationFrame(update);

      }

      fetchTrackInfo();
      registerEventHandlers();
      setInitialUniformValues();
      update();
      });             


    </script>
</body>
</html>
