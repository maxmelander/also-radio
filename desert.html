<!DOCTYPE html>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>DESERT STORM BRO</title>
    <style type="text/css">
          body {
            margin: 0;
          }

          #canvas {
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
          }
    </style>
</head>
<body>
    <canvas id="canvas" />
    <script type="text/javascript" src=
    "https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
    </script>
    <script type="glsl" id="FSHADER_SOURCE">
        #define DAY

        precision highp float;
        uniform float u_time;
        uniform vec2 u_resolution;

        vec3 _CameraPosition = vec3(0.0, 0.6, 3.0);

        /* COLORS */
        #ifdef DAY
        vec3 _SkyTopColor = vec3(0.18, 0.55, 1.0);
        vec3 _SkyBottomColor = vec3(0.95, 0.95, 0.9);
        vec3 _SunColor = vec3(5.4, 3.1, 2.0);
        vec3 _SkyColor = vec3(0.5, 0.6, 0.9);
        vec3 _BounceColor = vec3(0.6, 0.1, 0.1);
        vec3 _GlitterColor = vec3(0.5, 0.5, 0.3);
        vec3 _OceanColor = vec3(10.0, 10.0, 5.0);
        vec3 _DistanceColor = vec3(0.3, 0.3, 0.35);
        vec3 _SphereSpecColor = vec3(3.0, 3.0, 2.0);
        #else
        vec3 _SkyTopColor = vec3(0.00, 0.00, 0.01);
        vec3 _SkyBottomColor = vec3(0.01, 0.01, 0.02);
        vec3 _SunColor = vec3(0.1, 0.2, 0.6);
        vec3 _SkyColor = vec3(0.0, 0.0, 0.1);
        vec3 _BounceColor = vec3(0.04, 0.0, 0.0);
        vec3 _GlitterColor = vec3(0.2, 0.1, 0.2);
        vec3 _OceanColor = vec3(0.9, 0.9, 0.9);
        vec3 _DistanceColor = vec3(0.03, 0.03, 0.05);
        vec3 _SphereSpecColor = vec3(0.1, 0.0, 0.0);
        #endif

        vec3 _SandColor = vec3(0.18, 0.16, 0.13);
        vec3 _SphereColor = vec3(0.3, 0.1, 0.1);

        /* SIMPLEX NOISE */
// Simplex 2D noise
//
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}



        float smoothCurve( float x, float smoothingFactor ) {
            return x * x *( (3.0 - smoothingFactor) - (2.0 - smoothingFactor) * x );
        }

        float triangleWave( float x ) {
            return abs( fract( x + 0.5 ) * 2.0 - 1.0 );
        }

        float sharpTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.5 );
        }

        float smoothTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.0 );
        } 

        float smin( float a, float b, float k )
        {
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            return mix( b, a, h ) - k*h*(1.0-h);
        }

        float sdPlane( in vec3 pos )
        {

            float fh = -1.0 + 0.9 * (sharpTriangleWave(-0.2 + (0.1*pos.x) + 0.17*smoothTriangleWave(pos.x*0.1) + 0.3*smoothTriangleWave(pos.x*0.02)) + smoothTriangleWave(0.06*pos.z + 0.01*smoothTriangleWave(pos.z*0.2)));
            fh += pow(fh, 1.7);

            float hf = smoothTriangleWave(3.6*(pos.z + 0.02*smoothTriangleWave((pos.x + (u_time * 0.8)) * 2.6))); //+ smoothTriangleWave(20.*pos.y);
            float hf2 = smoothTriangleWave(2.*pos.x + (u_time * 1.));

            float d = pos.y - (fh + (0.025* hf * (clamp(-pos.y + 0.2, 0., 1.))) + (0.0026 * hf2 * (pos.y)));

            return d;
        }

        float sdEllipsoid( in vec3 p, in vec3 r )
        {
            float k0 = length(p/r);
            float k1 = length(p/(r*r));
            return k0*(k0-1.0)/k1;
        }

        float sdSphere( in vec3 pos, in float radius ) {

            float z = -2.0+ u_time;
            float y = 0.0 + ((1.0 + smoothTriangleWave(u_time * 0.1)) * 1.0);
            vec3 cen = vec3(0.0, y, z);

            return length(pos - cen) - radius;
        }

        vec2 map(in vec3 pos) {
            float d = -1.0;

            // Floating sphere
            // 
            // vec3 qos = vec3(mod(abs(pos.x), 11.0)-1.5, pos.y, mod(pos.z+1.5, 10.)-1.5);
            float d1 = sdSphere(pos, 1.);                            
                                                                     
            // Ground
            float d2 = sdPlane(pos);

            // Upside-down rain
            // vec3 qos = vec3(mod(abs(pos.x), 3.0)-1.5, pos.y, mod(pos.z+1.5, 3.)-1.5);
            // vec2 id = vec2(floor(abs(pos.x) / 3.0), floor(pos.z+1.5 / 3.));

            // float fid = id.x*11.1 + id.y*31.7;
            // float fy = fract(fid*0.312+u_time*0.1);
            // float y = -1. + 4.*fy;

            // vec3 radius = vec3(0.5, 0.2+0.3*smoothTriangleWave(fid * 130.2), 0.3);

            // float rain = sdEllipsoid(qos-vec3(0.5, 0.0, 0.0), radius);
            // rain *= 0.8;
            // rain = min(rain, 2.0);

            // Combine
            d = smin(d1, d2, 0.5);

            // d = smin(d, rain, 0.3);                               

            if (d1 < d2) {
                return vec2(d, 1.7);
            } else {
                return vec2(d, 1.0);
            }
        }

        
        float calcOcclusion( in vec3 pos, in vec3 nor )
        {
            float occ = 0.0;
            float sca = 1.0;
            for( int i=0; i<5; i++ )
            {
                float h = 0.01 + 0.11*float(i)/4.0;
                vec3 opos = pos + h*nor;
                float d = map( opos ).x;
                occ += (h-d)*sca;
                sca *= 0.95;
            }
            return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );
        }

        vec3 calcNormal(in vec3 pos) {
            vec2 e = vec2(0.0001, 0.0);
            return normalize( vec3( map(pos+e.xyy).x-map(pos-e.xyy).x,
                                    map(pos+e.yxy).x-map(pos-e.yxy).x,
                                    map(pos+e.yyx).x-map(pos-e.yyx).x));
        }

        vec2 textureMapping(in vec3 pos) {
            return pos.xz*vec2(0.03,0.07);
        }

        vec2 castRay(in vec3 ro, vec3 rd) {
            vec2 res = vec2(-1.0, -1.0);
            float tmin = 0.5;
            float tmax = 30.0;

            float t = tmin;

            for (int i = 0; i < 512; i++) {
                vec2 h = map(ro+rd*t);
                if (abs(h.x) < 0.001) {
                    res = vec2(t, h.y);
                    break;
                }
                t += h.x;

                if (t>tmax) {
                    break;
                }
                
            }

            return res;
        }

        float castShadow(in vec3 ro, vec3 rd) {
            float res = 1.0;

            float t = 0.001;
            for (int i = 0; i < 100; i++) {
                vec3 pos = ro + t*rd;
                float h = map(pos).x;

                res = min( res, 16.0*h / t );

                if ( h < 0.0001 ) break;

                t += h;

                if (t > 20.0) break;
            }

            return res;
        }


        vec3 nlerp(vec3 n1, vec3 n2, float t){
            return normalize(mix(n1, n2, t));
        }


        float diffuse(vec3 n, vec3 l) {
            n.y *= 0.3;
            float nDotL = clamp(4. * dot(n, l), 0.0, 1.0);
            return nDotL;
        }

        float rim(vec3 n, vec3 v) {
            float rim = 1.0 - clamp(dot(n, v), 0.0, 1.0);
            rim = clamp(pow(rim, 60.3) * 0.9, 0.0, 1.0);
            return rim;
        }

        float oceanSpecular(vec3 n, vec3 l, vec3 v) {
            // Blinn-Phong
            vec3 h = normalize(v + l); // Half direction
            float NdotH = max(0., dot(n, h));
            float specular = pow(NdotH, 700.0) * 1.7;
            return specular;
        }

        float glitterSpecular(vec2 uv, vec3 l, vec3 v, float threshold) {

            vec3 R = reflect(l, vec3(snoise(uv*300.), snoise(uv*400.), snoise(uv*440.)));

            float rDotV = max(0.0, dot(R, v));

            if (rDotV < threshold) {
                return 0.0;
            }
            return rDotV;
        }

        vec3 sandNormal(vec2 uv, vec3 n) {
            vec3 random = vec3(snoise(uv * 1420.), snoise(uv * 1420.), snoise(uv * 1500.));
            vec3 s = normalize(random);

            vec3 Ns = nlerp(n, s, 0.02);
            return Ns;
        }


        void main() {
            vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            float an = 0.1 * u_time;

            // Camera target
            vec3 ta = vec3(0., 0.5, 0.);

            _CameraPosition.z += u_time;
            // Ray origin
            vec3 ro = _CameraPosition;

            // Camera vectors
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));
            vec3 vv = normalize(cross(uu,ww));

            // Ray direction
            float fov = 1.6;
            vec3 rd = normalize(p.x * uu + p.y * vv + fov * ww);

            // Color
            vec3 col = mix(_SkyTopColor, _SkyBottomColor, exp(-10.0*rd.y));

            // SKY
            vec2 sky_uv = (gl_FragCoord.xy-0.5*u_resolution.xy) / u_resolution.y;
            //sky_uv *= 8.;
            //sky_uv = fract(sky_uv) - .5;

            //col = vec3(0);

            sky_uv.y -= 0.06;
            sky_uv.x += 0.02;
            float d = length(sky_uv);
            float m = .02 / d;//smoothstep(.2, .05, d);
            float moon = smoothstep(.1, .098, d);
            //float rays = max(0.0, 1.0 - abs(sky_uv.x * sky_uv.y * 3000.));
            //col += moon * vec3(0.8, 0.8, 0.8);
            //col += min(m, 0.9) * vec3(0.2, 0.2, 0.4);
            //col = vec3(col);

            

            // Ray marching
            vec2 tm = castRay(ro, rd);
            if (tm.y > 0.0) {
                float t = tm.x;
                vec3 pos = ro + t*rd;
                vec3 nor = calcNormal(pos);
                vec2 uv = fract(textureMapping(pos) * 4.);
                vec3 sand_nor = sandNormal(uv, nor);

                // Lights
                vec3 ocean_light = normalize(vec3(0., 2., -3.));
                vec3 sun_dir = normalize(vec3(-1.8, 5.6, -3.2));

                // Lighting
                float occ = calcOcclusion(pos, sand_nor);
                float sun_sha = clamp(castShadow(pos+sand_nor*0.01, sun_dir), 0.0 ,1.0);
                float sky_dif = 0.9 * diffuse(sand_nor, vec3(0.0, 1.0, 0.0));
                float bounce_dif = clamp(0.5 + 0.3*dot(sand_nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);
                float sun_dif = diffuse(sand_nor, sun_dir);
                float rim = rim(sand_nor, -rd);
                float oceanSpec = oceanSpecular(sand_nor, ocean_light, -rd) / (t/ 2.);
                float spec = max(rim, oceanSpec) / (t);
                float glitterSpec = glitterSpecular(uv, sun_dir, -rd, 0.9) / t;
                float glitterSpecLots = glitterSpecular(uv, sun_dir, -rd, 0.1) / t;

                vec3 mate = _SandColor;
                if (tm.y > 1.5) {
                    mate = _SphereColor;
                }

                vec3 li = vec3(0.0);
                li += sun_dif * _SunColor * sun_sha * occ;
                li += sky_dif * _SkyColor * occ;
                li += bounce_dif * _BounceColor * occ;

                col = li * mate;
                if (tm.y < 1.5) { // Sand
                    col += (glitterSpec * sun_dif * _GlitterColor * sun_sha);
                    col += (spec * glitterSpecLots * _OceanColor * sun_sha);
                } else { // Sphere
                    col += _SphereSpecColor * spec;
                }

                float distance = clamp((t-15.) / 20., 0.0, 1.0);
                col = mix(col, _DistanceColor, distance);      
                //col = li;
                //col = vec3(rim);
            }

            col = pow( col, vec3(0.4545) );

            gl_FragColor = vec4(col, 1.0); // return reddish-purple
        }
    </script>

    <script type="text/javascript">
        const fs = document.getElementById("FSHADER_SOURCE").textContent;
        const canvas = document.querySelector("#canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const sandbox = new GlslCanvas(canvas);
        sandbox.load(fs);
    </script>
</body>
</html>
