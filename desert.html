<!DOCTYPE html>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>DESERT STORM BRO</title>
    <style type="text/css">
          body {
            margin: 0;
          }

          #canvas {
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
          }

          button {
              z-index: 9999;
          }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button>play</button>
    <audio crossOrigin="anonymous">
        <source src="radio-1.mp3" type="audio/mpeg">
    </audio>

    <script type="text/javascript" src=
    "https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
    </script>
    <script type="glsl" id="FSHADER_SOURCE">
        // #define DAY        

        precision highp float;
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_bass;
        uniform float u_mid;
        uniform float u_high;
        uniform sampler2D u_texture;

        vec3 _CameraPosition = vec3(0.0, 0.6, 3.0);

        /* COLORS */
        #ifdef DAY
        vec3 _SkyTopColor = vec3(0.18, 0.55, 1.0);
        vec3 _SkyBottomColor = vec3(0.95, 0.95, 0.9);
        vec3 _SunColor = vec3(5.4, 3.1, 2.0);
        vec3 _SkyColor = vec3(0.5, 0.6, 0.9);
        vec3 _BounceColor = vec3(0.6, 0.1, 0.1);
        vec3 _GlitterColor = vec3(0.5, 0.5, 0.3);
        vec3 _OceanColor = vec3(10.0, 10.0, 5.0);
        vec3 _DistanceColor = vec3(0.3, 0.3, 0.35);
        vec3 _SphereSpecColor = vec3(3.0, 3.0, 2.0);
        #else
        vec3 _SkyTopColor = vec3(0.00, 0.00, 0.01);
        vec3 _SkyBottomColor = vec3(0.01, 0.01, 0.02);
        vec3 _SunColor = vec3(0.1, 0.2, 0.6);
        vec3 _SkyColor = vec3(0.0, 0.0, 0.1);
        vec3 _BounceColor = vec3(0.04, 0.0, 0.0);
        vec3 _GlitterColor = vec3(0.2, 0.1, 0.2);
        vec3 _OceanColor = vec3(0.9, 0.9, 0.9);
        vec3 _DistanceColor = vec3(0.03, 0.03, 0.05);
        vec3 _SphereSpecColor = vec3(0.1, 0.0, 0.0);
        #endif

        vec3 _SandColor = vec3(0.18, 0.16, 0.13);
        vec3 _SphereColor = vec3(0.4, 0.1, 0.1);

        /* SIMPLEX NOISE */
// Simplex 2D noise
//
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}



        float smoothCurve( float x, float smoothingFactor ) {
            return x * x *( (3.0 - smoothingFactor) - (2.0 - smoothingFactor) * x );
        }

        float triangleWave( float x ) {
            return abs( fract( x + 0.5 ) * 2.0 - 1.0 );
        }

        float sharpTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.5 );
        }

        float smoothTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.0 );
        } 

        float smin( float a, float b, float k )
        {
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            return mix( b, a, h ) - k*h*(1.0-h);
        }

        float sdPlane( in vec3 pos )
        {
            float amp = u_bass / 3.;

            float fh = -1.0 + (0.6 + amp) * (sharpTriangleWave(-0.2 + (0.1*pos.x) + 0.17*smoothTriangleWave(pos.x*0.1) + 0.3*smoothTriangleWave(pos.x*0.02)) + smoothTriangleWave(0.06*pos.z + 0.01*smoothTriangleWave(pos.z*0.2)));
            fh += pow(fh, 1.7);

            float hf = smoothTriangleWave(3.6*(pos.z + 0.02*smoothTriangleWave((pos.x + (u_time * 0.8)) * 2.6))); //+ smoothTriangleWave(20.*pos.y);
            float hf2 = smoothTriangleWave(2.*pos.x + (u_time * 1.));

            float d = pos.y - (fh + ((0.098*(u_high*0.8))* hf * (clamp(-pos.y + 0.2, 0., 1.))) + (0.0026 * hf2 * (pos.y)));

            return d;
        }

        float sdEllipsoid( in vec3 p, in vec3 r )
        {
            float k0 = length(p/r);
            float k1 = length(p/(r*r));
            return k0*(k0-1.0)/k1;
        }

        float sdSphere( in vec3 pos, in float radius ) {

            float z = -2.0- (u_time + u_mid);
            float y = -0.3 + ((0.6 + smoothTriangleWave(u_time * 0.1)) * 0.7);
            vec3 cen = vec3(mix(-0.3, 0.3, sin(u_time * 0.05)), y, z);
                         
            return length(pos - cen) - (radius + (u_mid/ 6.));
        }

        vec2 map(in vec3 pos) {
            float d = -1.0;

            // Floating sphere
            // 
            // vec3 qos = vec3(mod(abs(pos.x), 11.0)-1.5, pos.y, mod(pos.z+1.5, 10.)-1.5);
            float d1 = sdSphere(pos, 0.5);                            

            //vec3 pos_2 = vec3(pos.x + (0.2 * u_mid * sin(u_time)) + sin(u_time * 0.2), pos.y - (0.2* u_bass) * sin(u_time * 0.8), pos.z + ( 0.8 * cos(u_time * 0.5)));
            //vec3 pos_3 = vec3(pos.x - (0.1 * u_mid * sin(u_time * 1.2)) - sin(u_time * 0.3), pos.y + (0.3* u_bass) * sin(u_time * 0.3), pos.z + ( 0.8 * cos(u_time * 0.5)));

            //float f3 = sdSphere(pos_2, 0.3);
            //float f4 = sdSphere(pos_3, 0.2);
            // d1 = smin(d1, f3, 0.5);
            //d1 = smin(d1, f4, 0.5);
                                                                     
            // Ground
            float d2 = sdPlane(pos);

            // Upside-down rain
            // vec3 qos = vec3(mod(abs(pos.x), 3.0)-1.5, pos.y, mod(pos.z+1.5, 3.)-1.5);
            // vec2 id = vec2(floor(abs(pos.x) / 3.0), floor(pos.z+1.5 / 3.));

            // float fid = id.x*11.1 + id.y*31.7;
            // float fy = fract(fid*0.312+u_time*0.1);
            // float y = 0. + sin(u_time);

            // vec3 radius = vec3(0.5, 0.4+0.3*smoothTriangleWave(fid * 130.2), 0.3);

            // float rain = sdEllipsoid(qos-vec3(0.5, y, 0.0), radius);
            // rain *= 0.8;
            // rain = min(rain, 2.0);

            // Combine
            d = smin(d1, d2, 0.5);

            // d = smin(d, rain, 0.3);                               

            if (d1 < d2) {
                return vec2(d, 1.7);
            } else {
                return vec2(d, 1.0);
            }
        }

        
        float calcOcclusion( in vec3 pos, in vec3 nor )
        {
            float occ = 0.0;
            float sca = 1.0;
            for( int i=0; i<5; i++ )
            {
                float h = 0.01 + 0.11*float(i)/4.0;
                vec3 opos = pos + h*nor;
                float d = map( opos ).x;
                occ += (h-d)*sca;
                sca *= 0.95;
            }
            return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );
        }

        vec3 calcNormal(in vec3 pos) {
            vec2 e = vec2(0.0001, 0.0);
            return normalize( vec3( map(pos+e.xyy).x-map(pos-e.xyy).x,
                                    map(pos+e.yxy).x-map(pos-e.yxy).x,
                                    map(pos+e.yyx).x-map(pos-e.yyx).x));
        }

        vec2 textureMapping(in vec3 pos) {
            return pos.xz*vec2(0.03,0.07);
        }

        vec2 castRay(in vec3 ro, vec3 rd) {
            vec2 res = vec2(-1.0, -1.0);
            float tmin = 0.5;
            float tmax = 30.0;

            float t = tmin;

            for (int i = 0; i < 512; i++) {
                vec2 h = map(ro+rd*t);
                if (abs(h.x) < 0.001) {
                    res = vec2(t, h.y);
                    break;
                }
                t += h.x;

                if (t>tmax) {
                    break;
                }
                
            }

            return res;
        }

        float castShadow(in vec3 ro, vec3 rd) {
            float res = 1.0;

            float t = 0.001;
            for (int i = 0; i < 100; i++) {
                vec3 pos = ro + t*rd;
                float h = map(pos).x;

                res = min( res, 16.0*h / t );

                if ( h < 0.0001 ) break;

                t += h;

                if (t > 20.0) break;
            }

            return res;
        }


        vec3 nlerp(vec3 n1, vec3 n2, float t){
            return normalize(mix(n1, n2, t));
        }


        float diffuse(vec3 n, vec3 l) {
            n.y *= 0.3;
            float nDotL = clamp(4. * dot(n, l), 0.0, 1.0);
            return nDotL;
        }

        float rim(vec3 n, vec3 v) {
            float rim = 1.0 - clamp(dot(n, v), 0.0, 1.0);
            rim = clamp(pow(rim, 60.3) * 0.9, 0.0, 1.0);
            return rim;
        }

        float oceanSpecular(vec3 n, vec3 l, vec3 v) {
            // Blinn-Phong
            vec3 h = normalize(v + l); // Half direction
            float NdotH = max(0., dot(n, h));
            float specular = pow(NdotH, 600.0) * 2.7;
            return specular;
        }

        float glitterSpecular(vec2 uv, vec3 l, vec3 v, float threshold) {

            vec3 R = reflect(l, vec3(snoise(uv*300.), snoise(uv*400.), snoise(uv*440.)));

            float rDotV = max(0.0, dot(R, v));

            if (rDotV < threshold) {
                return 0.0;
            }
            return rDotV;
        }

        vec3 sandNormal(vec2 uv, vec3 n) {
            vec3 random = vec3(snoise(uv * 1420.), snoise(uv * 1420.), snoise(uv * 1500.));
            vec3 s = normalize(random);

            vec3 Ns = nlerp(n, s, 0.02);
            return Ns;
        }

        vec4 blur(sampler2D image, vec2 uv) {
            const float Pi = 6.28318530718; // Pi*2
    
            // GAUSSIAN BLUR SETTINGS {{{
            const float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)
            const float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)
            const float Size = 12.0; // BLUR SIZE (Radius)
            // GAUSSIAN BLUR SETTINGS }}}

            vec2 Radius = Size/u_resolution.xy;

            // Pixel colour
            vec4 Color = texture2D(image, uv);

            // Blur calculations
            for( float d=0.0; d<Pi; d+=Pi/Directions)
            {
                for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)
                {
                    Color += texture2D(image, uv+vec2(cos(d),sin(d))*Radius*i);
                }
            }

            // Output to screen
            Color /= Quality * Directions - 15.0;

            return Color;
        }


        void main() {
            vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            float an = 0.1 * u_time;

            // Camera target
            vec3 ta = _CameraPosition - vec3(0., 0.5, 800.);

            _CameraPosition.z -= u_time;
            //_CameraPosition.x += 0. + (0.2 * sin(u_time * 0.2));
            // Ray origin
            vec3 ro = _CameraPosition;

            // Camera vectors
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));
            vec3 vv = normalize(cross(uu,ww));

            // Ray direction
            float fov = 1.6;
            vec3 rd = normalize(p.x * uu + p.y * vv + fov * ww);

            // Color
            vec3 col = mix(_SkyTopColor, _SkyBottomColor, exp(-10.0*rd.y));

            // SKY
            vec2 sky_uv = (gl_FragCoord.xy-0.5*u_resolution.xy) / u_resolution.y;
            vec2 logo_uv = sky_uv * 1.8;
            logo_uv.x += 0.5;
            logo_uv.y += 0.36;
            //sky_uv = (sky_uv + 1.0) / 2.;

            //sky_uv *= 8.;
            //sky_uv.y -= 1.0;
            sky_uv.x += 0.02 - (0.1 * sin(u_time * 0.5));
            //sky_uv = fract(sky_uv) - .5;
            //
            //vec4 logo_blur = blur5(u_texture, logo_uv, vec2(600., 600.), vec2(6., 0.));
            vec4 logo_hue = vec4(1.2, 1.0, 1.0, 2.0);
            vec4 logo_blur = clamp(blur(u_texture, logo_uv), 0., 1.);
            vec4 logo = clamp(texture2D(u_texture, logo_uv), 0., 1.);

            //vec4 logo = sampler2D(u_texture, logo_uv);

            vec4 logo_color = clamp(logo * (0.7 + u_bass) + (logo_blur * (u_bass)), 0.0 , 1.0) * logo_hue;
            //logo_blur += blur5(u_texture, logo_uv, vec2(300., 300.), vec2(0., 1.));
            //col = vec3(0);
            //float logo_mask = texture2D(u_texture, logo_uv).r;
            //float logo_mask_neg = smoothstep(.1, .01, logo_mask);

            float d = length(sky_uv);
            float m = .01 / d;//smoothstep(.2, .05, d);

            //m *= logo_mask_neg;
            //float moon = smoothstep(.2, .05, d);

                           

            //float rays = max(0.0, 1.0 - abs(sky_uv.x * sky_uv.y * 3000.));
            //col += moon * vec3(0.5, 0.5, 0.5);
            col +=  (min(m, 0.9) * vec3(0.2 + (u_mid * 0.3), 0.2, 0.4));
            col += logo_color.rgb;

            // Ray marching
            vec2 tm = castRay(ro, rd);
            if (tm.y > 0.0) {
                float t = tm.x;
                vec3 pos = ro + t*rd;
                vec3 nor = calcNormal(pos);
                vec2 uv = fract(textureMapping(pos) * 4.);
                vec3 sand_nor = sandNormal(uv, nor);

                // Lights
                vec3 ocean_light = normalize(vec3(0., 2., -3.));
                vec3 sun_dir = normalize(vec3(0. + 4.* sin(u_time * 0.5), 5.6, -3.2));

                // Lighting
                float occ = calcOcclusion(pos, sand_nor);
                float sun_sha = clamp(castShadow(pos+sand_nor*0.01, sun_dir), 0.0 ,1.0);
                float sky_dif = 0.9 * diffuse(sand_nor, vec3(0.0, 1.0, 0.0));
                float bounce_dif = clamp(0.5 + 0.3*dot(sand_nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);
                float sun_dif = diffuse(sand_nor, sun_dir);
                float rim = rim(sand_nor, -rd);
                float oceanSpec = oceanSpecular(sand_nor, ocean_light, -rd) / (t/ 2.);
                float spec = max(rim, oceanSpec) / (t);
                float glitterSpec = glitterSpecular(uv, sun_dir, -rd, 0.9) / t;
                float glitterSpecLots = glitterSpecular(uv, sun_dir, -rd, 0.1) / t;

                vec3 mate = _SandColor;
                if (tm.y > 1.5) {
                    mate = _SphereColor;
                }

                vec3 li = vec3(0.0);
                li += sun_dif * _SunColor * sun_sha * occ;
                li += sky_dif * _SkyColor * occ;
                li += bounce_dif * _BounceColor * occ;

                col = li * mate;
                if (tm.y < 1.5) { // Sand
                    _GlitterColor = vec3(_GlitterColor.r + (u_mid * 0.4), _GlitterColor.g, _GlitterColor.b + (u_mid * 0.1));
                    _OceanColor = vec3(_OceanColor.r + (u_mid * 0.4), _OceanColor.g, _OceanColor.b + (u_mid * 0.1));
                    col += (glitterSpec * sun_dif * _GlitterColor * sun_sha);
                    col += (spec * glitterSpecLots * _OceanColor * sun_sha);
                } else { // Sphere
                    col += _SphereSpecColor * spec;
                }

                float distance = clamp((t-15.) / 20., 0.0, 1.0);
                col = mix(col, _DistanceColor, distance);      
                //col = li;
                //col = vec3(rim);
            }

            col = pow( col, vec3(0.4545) );

            gl_FragColor = vec4(col, 1.0); // return reddish-purple
        }
    </script>
    <script type="text/javascript">

        // Audio setup
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioCtx();
        const analyser = audioContext.createAnalyser();
        const audioElement = document.querySelector('audio');
        const audioSource = audioContext.createMediaElementSource(audioElement);

        audioSource.connect(analyser);      
        analyser.connect(audioContext.destination);       

        analyser.fftSize = 1024;
        var bufferLength = analyser.frequencyBinCount;
        var dataArray = new Uint8Array(bufferLength);
                                              
        const playButton = document.querySelector('button');
        playButton.addEventListener('click', () => {
            audioContext.resume();
            audioElement.currentTime = 0;
            audioElement.play();
        });           

        // Canvas setup
        const fs = document.getElementById("FSHADER_SOURCE").textContent;
        const canvas = document.querySelector("#canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const sandbox = new GlslCanvas(canvas);
        sandbox.load(fs);

        // Uniforms
        sandbox.setUniform("u_texture","logo.jpg");

        console.log("BUFFER LENGTH");
        console.log(bufferLength);
        const update = (timestamp) => {
            analyser.getByteFrequencyData(dataArray);
            const bass = dataArray.slice(0, 3).reduce((acc, e) => acc+e) / 3;
            const mid = dataArray.slice(100, 300).reduce((acc, e) => acc+e) / 199;
            const high = dataArray.slice(300, 500).reduce((acc, e) => acc+e) / 199;
            sandbox.setUniform("u_bass", bass / 255);
            sandbox.setUniform("u_mid", mid / 255);
            sandbox.setUniform("u_high", high / 255);
            window.requestAnimationFrame(update);
        }

        window.requestAnimationFrame(update);
    </script>
</body>
</html>
