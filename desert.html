<!DOCTYPE html>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Also Radio</title>
    <style type="text/css">
          body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            background: black;
          }

          h1, p {              
              font-family: 'helvetica';
          }

          p {
              font-size: 24px;
              padding: 12px;
              border-radius: 12px;
              margin: 0;
          }

          p:hover {
              cursor: pointer;
          }

          #canvas {
            width: 80vw;
            height: 80vh;
            box-sizing: border-box;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 24px;
            z-index: 0;
          }

          #tracklist {
              position: absolute;
              bottom: 12px;    
              right: 12px;  
          }

          .track--selected p {
              background: white;
              color: black;
          }

          button {
              z-index: 9999;
          }

          h1 {
              color: white;
              font-size: 69px;
              position: absolute;
              z-index: 1;
          }

          p {
              color: white; 
          }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <h1 id="fps"></h1>
    <div id="tracklist"></div>
    <audio crossOrigin="anonymous" src= type="audio/mpeg">
    </audio>
    <script type="text/javascript" src=
    "https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
    </script>
    <script type="glsl" id="FSHADER_SOURCE">
        #define DAY        

        precision highp float;
        uniform vec2 u_mouse;
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform sampler2D u_texture;

        uniform float u_bass;
        uniform float u_mid;
        uniform float u_high;

        uniform float u_tod; // time of day mix from 0 -> 1
        uniform float u_distort; // mix in field distortion effect
        uniform float u_ballSpeed;

        vec3 _CameraPosition = vec3(0.0, 0.6, 3.0);

        /* COLORS */

        // Day
        vec3 _SkyTopColor_0 = vec3(0.18, 0.55, 1.0);
        vec3 _SkyBottomColor_0 = vec3(0.95, 0.95, 0.9);
        vec3 _SunColor_0 = vec3(5.4, 3.1, 2.0);
        vec3 _SkyColor_0 = vec3(0.5, 0.6, 0.9);
        vec3 _BounceColor_0 = vec3(0.6, 0.1, 0.1);
        vec3 _GlitterColor_0 = vec3(0.5, 0.5, 0.3);
        vec3 _OceanColor_0 = vec3(10.0, 10.0, 5.0);
        vec3 _DistanceColor_0 = vec3(0.3, 0.3, 0.35);
        vec3 _SphereSpecColor_0 = vec3(3.0, 3.0, 2.0);
        vec3 _FresnelColor_0 = vec3(1.0, 0.5, 0.5);

        // Night
        vec3 _SkyTopColor_1 = vec3(0.00, 0.00, 0.01);
        vec3 _SkyBottomColor_1 = vec3(0.01, 0.01, 0.02);
        vec3 _SunColor_1 = vec3(0.1, 0.2, 0.6);
        vec3 _SkyColor_1 = vec3(0.0, 0.0, 0.1);
        vec3 _BounceColor_1 = vec3(0.04, 0.0, 0.0);
        vec3 _GlitterColor_1 = vec3(0.2, 0.1, 0.2);
        vec3 _OceanColor_1 = vec3(1.9, 0.9, 0.9);
        vec3 _DistanceColor_1 = vec3(0.03, 0.03, 0.05);
        vec3 _SphereSpecColor_1 = vec3(0.5, 0.2, 0.5);
        vec3 _FresnelColor_1 = vec3(0.15, 0.05, 0.05);

        // Golden
        vec3 _SkyTopColor_2 = vec3(0.78, 0.35, 0.2);
        vec3 _SkyBottomColor_2 = vec3(0.85, 0.25, 0.2);
        vec3 _SunColor_2 = vec3(4.0, 1.1, 0.7);
        vec3 _SkyColor_2 = vec3(0.5, 0.1, 0.2);
        vec3 _BounceColor_2 = vec3(0.6, 0.1, 0.1);
        vec3 _GlitterColor_2 = vec3(0.3, 0.3, 0.5);
        vec3 _OceanColor_2 = vec3(2.0, 2.0, 10.0);
        vec3 _DistanceColor_2 = vec3(0.49, 0.1, 0.1);
        vec3 _SphereSpecColor_2 = vec3(3.0, 1.0, 1.0);

        vec3 _SkyTopColor = mix(_SkyTopColor_0, _SkyTopColor_1, u_tod);
        vec3 _SkyBottomColor =  mix(_SkyBottomColor_0, _SkyBottomColor_1, u_tod);
        vec3 _SunColor = mix(_SunColor_0, _SunColor_1, u_tod);
        vec3 _SkyColor = mix(_SkyColor_0, _SkyColor_1, u_tod);
        vec3 _BounceColor = mix(_BounceColor_0, _BounceColor_1, u_tod);
        vec3 _GlitterColor = mix(_GlitterColor_0, _GlitterColor_1, u_tod);
        vec3 _OceanColor = mix(_OceanColor_0, _OceanColor_1, u_tod);
        vec3 _DistanceColor = mix(_DistanceColor_0, _DistanceColor_1, u_tod);
        vec3 _SphereSpecColor = mix(_SphereSpecColor_0, _SphereSpecColor_1, u_tod);
        vec3 _FresnelColor = mix(_FresnelColor_0, _FresnelColor_1, u_tod);

        vec3 _SandColor = vec3(0.18, 0.16, 0.13);
        vec3 _SphereColor = vec3(0.2, 0.1, 0.4);

        /* SIMPLEX NOISE */
// Simplex 2D noise
//
        vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

        float snoise(vec2 v){
            const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                    -0.577350269189626, 0.024390243902439);
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
            + i.x + vec3(0.0, i1.x, 1.0 ));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                dot(x12.zw,x12.zw)), 0.0);
            m = m*m ;
            m = m*m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
            vec3 g;
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

        float smoothCurve( float x, float smoothingFactor ) {
            return x * x *( (3.0 - smoothingFactor) - (2.0 - smoothingFactor) * x );
        }

        float triangleWave( float x ) {
            return abs( fract( x + 0.5 ) * 2.0 - 1.0 );
        }

        float sharpTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.5 );
        }

        float smoothTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ), 0.0 );
        } 

        float smin( float a, float b, float k )
        {
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            return mix( b, a, h ) - k*h*(1.0-h);
        }

        float sdPlane(vec3 pos)
        {
            float amp = u_bass / 3.;

            float fh = -1.0 + (0.6 + amp) * (sharpTriangleWave(-0.2 + (0.1*pos.x) + 0.17*smoothTriangleWave(pos.x*0.1) + 0.3*smoothTriangleWave(pos.x*0.02)) + smoothTriangleWave(0.06*pos.z + 0.01*smoothTriangleWave(pos.z*0.2)));
            fh += pow(abs(fh), 1.7);

            float hf = smoothTriangleWave(3.6*(pos.z + 0.02*smoothTriangleWave((pos.x + (u_time * 0.9)) * 2.6))); //+ smoothTriangleWave(20.*pos.y);
            float hf2 = smoothTriangleWave(2.*pos.x + (u_time * 1.));

            float d = pos.y - (fh + ((0.138*(u_high*2.4))* hf * (clamp(-pos.y + 0.2, 0., 1.))) + (0.0026 * hf2 * (pos.y)));

            return d;
        }

        float sdSphere(vec3 pos, float radius) {

            float z = -2.0- (u_time - (u_mid * 1.2));
            float y = -0.3 + ((0.6 + (smoothTriangleWave(u_time * 0.1)) ) * 0.7);
            vec3 cen = vec3(mix(-0.3, 0.3, smoothTriangleWave(u_time * 0.015)), y, z);
                         
            return length(pos - cen) - (radius + (u_mid/ 6.));
        }

        float sdMetaballs(vec3 pos) {
             // Floating spheres
            float result = sdSphere(pos, 0.5);                            

            vec3 pos_2 = vec3(pos.x + (0.2 * u_mid * smoothTriangleWave(u_time * 0.5)) + smoothTriangleWave(u_time * (0.1 * u_ballSpeed)), pos.y - (0.2* u_bass) * smoothTriangleWave(u_time * 0.4) -(0.3 * smoothTriangleWave(u_time * (0.033 * u_ballSpeed))), pos.z + ( 0.8 * cos(u_time * (0.5 * u_ballSpeed))));
            vec3 pos_3 = vec3(pos.x - (0.1 * u_mid * smoothTriangleWave(u_time * 0.6)) - smoothTriangleWave(u_time * (0.05 * u_ballSpeed)), pos.y + (0.3* u_bass) * smoothTriangleWave(u_time * 0.05) - (0.5 * smoothTriangleWave(u_time * (0.08 * u_ballSpeed))), pos.z + ( 0.8 * cos(u_time * (0.5 * u_ballSpeed))));

            float ball_2 = sdSphere(pos_2, 0.4);
            float ball_3 = sdSphere(pos_3, 0.3);

            result = smin(result, ball_2, 0.5);
            result = smin(result, ball_3, 0.5);           

            return result;
        }

        vec2 map(vec3 pos) {
            float d = -1.0;

            // Metaballs
            vec3 ball_pos = pos;
            ball_pos.x = mod(abs(ball_pos.x), 5.0) - 1.5;
            ball_pos.z += 0.3 * (sin(abs(ball_pos.z) * 1.0) - 0.5);

            float d1 = sdMetaballs(mix(pos, ball_pos, u_distort));
                                                                     
            // Ground
            float d2 = sdPlane(pos);

            // Combine
            d = smin(d1, d2, 0.5);

            if (d1 < d2) {
                return vec2(d, 1.7);
            } else {
                return vec2(d, 1.0);
            }
        }

        
        float calcOcclusion(vec3 pos, vec3 nor)
        {
            float occ = 0.0;
            float sca = 1.0;
            for( int i=0; i<5; i++ )
            {
                float h = 0.01 + 0.11*float(i)/4.0;
                vec3 opos = pos + h*nor;
                float d = map( opos ).x;
                occ += (h-d)*sca;
                sca *= 0.95;
            }
            return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );
        }

        vec3 calcNormal(vec3 pos) {
            vec2 e = vec2(0.0001, 0.0);
            return normalize( vec3( map(pos+e.xyy).x-map(pos-e.xyy).x,
                                    map(pos+e.yxy).x-map(pos-e.yxy).x,
                                    map(pos+e.yyx).x-map(pos-e.yyx).x));
        }

        vec2 textureMapping(vec3 pos) {
            return pos.xz*vec2(0.03,0.07);
        }

        vec2 castRay(vec3 ro, vec3 rd) {
            vec2 res = vec2(-1.0, -1.0);
            float tmin = 0.5;
            float tmax = 30.0;

            float t = tmin;

            for (int i = 0; i < 450; i++) {
                vec2 h = map(ro+rd*t);
                if (abs(h.x) < 0.01) {
                    res = vec2(t, h.y);
                    break;
                }
                t += h.x;

                if (t>tmax) {
                    break;
                }
                
            }

            return res;
        }

        float castShadow(vec3 ro, vec3 rd) {
            float res = 1.0;

            float t = 0.001;
            for (int i = 0; i < 100; i++) {
                vec3 pos = ro + t*rd;
                float h = map(pos).x;

                res = min( res, 16.0*h / t );

                if ( h < 0.0001 ) break;

                t += h;

                if (t > 20.0) break;
            }

            return res;
        }


        vec3 nlerp(vec3 n1, vec3 n2, float t){
            return normalize(mix(n1, n2, t));
        }


        float diffuse(vec3 n, vec3 l) {
            n.y *= 0.3;
            float nDotL = clamp(4. * dot(n, l), 0.0, 1.0);
            return nDotL;
        }

        float rim(vec3 n, vec3 v) {
            float rim = 1.0 - clamp(dot(n, v), 0.0, 1.0);
            rim = clamp(pow(rim, 60.3) * 0.9, 0.0, 1.0);
            return rim;
        }

        float oceanSpecular(vec3 n, vec3 l, vec3 v) {
            // Blinn-Phong
            vec3 h = normalize(v + l); // Half direction
            float NdotH = max(0., dot(n, h));
            float specular = pow(NdotH, 600.0) * 2.7;
            return specular;
        }

        float glitterSpecular(vec2 uv, vec3 l, vec3 v, float threshold, vec3 noise) {

            vec3 R = reflect(l, noise);

            float rDotV = max(0.0, dot(R, v));

            if (rDotV < threshold) {
                return 0.0;
            }
            return rDotV;
        }

        vec3 sandNormal(vec2 uv, vec3 n) {
            vec3 random = vec3(snoise(uv * 1420.), snoise(uv * 1420.), snoise(uv * 1500.));
            vec3 s = normalize(random);

            vec3 Ns = nlerp(n, s, 0.02);
            return Ns;
        }

        vec4 blur(sampler2D image, vec2 uv) {
            const float Pi = 6.28318530718; // Pi*2
    
            // GAUSSIAN BLUR SETTINGS {{{
            const float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)
            const float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)
            const float Size = 12.0; // BLUR SIZE (Radius)
            // GAUSSIAN BLUR SETTINGS }}}

            vec2 Radius = Size/u_resolution.xy;

            // Pixel colour
            vec4 Color = texture2D(image, uv);

            // Blur calculations
            for( float d=0.0; d<Pi; d+=Pi/Directions)
            {
                for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)
                {
                    Color += texture2D(image, uv+vec2(cos(d),((smoothTriangleWave(d * 0.2) * 2.0) - 1.))*Radius*i);
                }
            }

            // Output to screen
            Color /= Quality * Directions - 15.0;

            return Color;
        }

        vec3 fresnelSchlick(vec3 N, vec3 I){
            vec3 F0 = vec3(0.0);
            return F0 + (1.0 - F0) * pow(1.0 - (dot(N, I)), 5.0);
        }

        void main() {
            vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;


            _CameraPosition.z -= u_time;

            // Camera target
            vec3 ta = _CameraPosition - vec3(0., 0.5, 800.);
            // Ray origin
            vec3 ro = _CameraPosition;

            // Camera vectors
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));
            vec3 vv = normalize(cross(uu,ww));

            // Ray direction
            float fov = 1.6;
            vec3 rd = normalize(p.x * uu + p.y * vv + fov * ww);

            // Color
            vec3 col = mix(_SkyTopColor, _SkyBottomColor, exp(-10.0*rd.y));

            // STARS
            vec2 star_uv = (gl_FragCoord.xy-0.5*u_resolution.xy) / u_resolution.y;
            star_uv *= 12.;
            vec2 star_gv = fract(star_uv) - .5;
            vec2 star_id = floor(star_uv);

            float star_noise = snoise(star_id);
            float star_distance = length(vec2(star_gv.x + ((star_noise - .5) * 0.8), star_gv.y + (fract(star_noise * 94.281)-.5) * 0.8)) * 8.;
            float star_strength = smoothstep(.15, .05, star_distance);
            float star_glow = smoothstep(2.35, .005, star_distance);
            col += vec3(star_strength*((star_noise * .4) + (u_mid * 0.9))) + (0.001 * vec3(star_glow)) * vec3(star_noise);

            // SKY
            vec2 sky_uv = (gl_FragCoord.xy-0.5*u_resolution.xy) / u_resolution.y;
            vec2 logo_uv = sky_uv * 1.8;
            logo_uv.x += 0.5;
            logo_uv.y += 0.36;

            // Animation: soon/moon
            float sun_pos_wave = (smoothTriangleWave(u_time * 0.1) * 2.) - 1.;
            sky_uv.x += 0.02 - (0.1 * sun_pos_wave);

            vec4 logo_hue = vec4(1.2, 1.0, 1.0, 1.0);
            vec4 logo_blur = clamp(blur(u_texture, logo_uv), 0., 1.);
            vec4 logo = clamp(texture2D(u_texture, logo_uv), 0., 1.);
            vec4 logo_color = clamp(logo * (0.05 + u_bass) + (logo_blur * (u_bass * 0.4)), 0.0 , 1.0) * logo_hue;

            float d = length(sky_uv);
            float m = .01 / d;//smoothstep(.2, .05, d);

            col +=  (min(m, 0.9) * vec3(0.2 + (u_mid * 0.6), 0.2, 0.4));
            col += logo_color.rgb;


            vec2 tm = castRay(ro, rd);
            if (tm.y > 0.0) {
                float t = tm.x;
                vec3 pos = ro + t*rd;
                vec3 nor = calcNormal(pos);
                vec2 uv = fract(textureMapping(pos) * 4.);
                vec3 sand_nor = sandNormal(uv, nor);

                // Lights
                vec3 ocean_light = normalize(vec3(0., 2., -3.));
                vec3 sun_dir = normalize(vec3(0. + 4.* sun_pos_wave, 5.6, -3.2));

                // Lighting
                float occ = calcOcclusion(pos, sand_nor);
                float sun_sha = clamp(castShadow(pos+sand_nor*0.01, sun_dir), 0.0 ,1.0);
                float sky_dif = 0.9 * diffuse(sand_nor, vec3(0.0, 1.0, 0.0));
                float bounce_dif = clamp(0.5 + 0.3*dot(sand_nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);
                float sun_dif = diffuse(sand_nor, sun_dir);
                float rim = rim(sand_nor, -rd);
                float oceanSpec = oceanSpecular(sand_nor, ocean_light, -rd) / (t/ 2.);
                float spec = max(rim, oceanSpec) / (t);

                vec3 glitterNoise = vec3(snoise(uv*300.), snoise(uv*400.), snoise(uv*440.));
                float glitterSpec = glitterSpecular(uv, sun_dir, -rd, 0.9, glitterNoise) / t;
                float glitterSpecLots = glitterSpecular(uv, sun_dir, -rd, 0.2, glitterNoise) / t;

                vec3 mate = _SandColor;
                if (tm.y > 1.5) {
                    mate = _SphereColor;
                }

                // Light color
                vec3 li = vec3(0.0);
                li += sun_dif * _SunColor * sun_sha * occ;
                li += sky_dif * _SkyColor * occ;
                li += bounce_dif * _BounceColor * occ;

                // Material color
                col = li * mate;
                if (tm.y < 1.5) { // Sand
                    _GlitterColor = vec3(_GlitterColor.r + (u_mid * 0.8), _GlitterColor.g, _GlitterColor.b + (u_mid * 0.3));
                    _OceanColor = vec3(_OceanColor.r + (u_mid * 0.4), _OceanColor.g, _OceanColor.b + (u_mid * 0.1));
                    col += (glitterSpec * sun_dif * _GlitterColor * sun_sha);
                    col += (spec * glitterSpecLots * _OceanColor * sun_sha);
                } else { // Sphere
                    vec3 fresnel = fresnelSchlick(sand_nor, -rd);
                    col += _SphereSpecColor * spec;
                    col += fresnel * _FresnelColor;
                    //col += vec3(1., 1., 1.) * 1. - 
                }

                float distance = clamp((t-15.) / 20., 0.0, 1.0);
                col = mix(col, _DistanceColor, distance);      
            }

            col = pow( col, vec3(0.4545) );

            if (u_distort == 1.) {
                // col.g = mix(col.g, 0.1 - col.g, u_bass * 0.5);
                //col.r = mix(col.g, 0.9 - col.r, 0.);
            }

            gl_FragColor = vec4(col, 1.0); // return reddish-purple
        }
    </script>
    <script type="text/javascript">
        // Canvas setup
        const fs = document.getElementById("FSHADER_SOURCE").textContent;
        const canvas = document.querySelector("#canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const sandbox = new GlslCanvas(canvas);
        sandbox.load(fs);

        let tracks = [];

        const infoUrl = "https://api.soundcloud.com/users/287905929/tracks?client_id=9e05e349251475056d1bc81acbf08c71&secret_token=track";

        let selectedTrack = null;
    
        fetch(infoUrl)
            .then(response => response.json())
            .then(data => {
                tracks = data.map(t => {
                    return {
                        id: t.id, title: t.title
                    }});

                selectedTrack = tracks[0];

                console.log(data);

                const parent = document.getElementById("tracklist");
                data.forEach((track, i) => {
                    const child = document.createElement("div");
                    child.id = track.id;
                    child.onclick = () => {
                        handleTrackClick(i);
                    }

                    child.insertAdjacentHTML("beforeend", `<p>${track.title}</p>`);
                    parent.appendChild(child);
                })
            });

        const getStreamUrl = (trackId) => (
            `https://api.soundcloud.com/tracks/${trackId}/stream?client_id=9e05e349251475056d1bc81acbf08c71&secret_token=track`
        )
    
        // Audio setup
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioCtx();
        const analyser = audioContext.createAnalyser();
        const audioElement = document.querySelector('audio');                                                                       
        const audioSource = audioContext.createMediaElementSource(audioElement);

        // Animation variables
        let isPlaying = false;
        let isDistorting = false;

        let ballSpeed = 0.2;
        const ballAcceleration = 0.01;
        const ballSpeedNormal = 0.8;
        const ballSpeedFast = 2.2;

        const play = () => {
            if (selectedTrack) {
                audioElement.src = getStreamUrl(selectedTrack.id);
                audioContext.resume();
                audioElement.currentTime = 180;
                audioElement.play();               

                isPlaying = true;
            }
        }

        const handleTrackClick = (trackIndex) => {
            const oldElement = document.getElementById(`${selectedTrack.id}`)
            oldElement.classList.remove("track--selected");

            selectedTrack = tracks[trackIndex];

            const newElement = document.getElementById(`${selectedTrack.id}`)
            newElement.classList.add("track--selected");
            play();         
        }

        audioSource.connect(analyser);      
        analyser.connect(audioContext.destination);       

        analyser.fftSize = 1024;
        var bufferLength = analyser.frequencyBinCount;
        var dataArray = new Uint8Array(bufferLength);
                                              


        // Uniforms
        sandbox.setUniform("u_texture","logo.jpg");
        sandbox.setUniform("u_ballSpeed", ballSpeed);

        console.log("BUFFER LENGTH");
        console.log(bufferLength);

        let oldTime = 0;

        sandbox.setUniform("u_tod", 1);
        const update = (timestamp) => {
            analyser.getByteFrequencyData(dataArray);
            const bass = dataArray.slice(0, 4).reduce((acc, e) => acc+e) / 4;
            const mid = dataArray.slice(100, 300).reduce((acc, e) => acc+e) / 199;
            const high = dataArray.slice(300, 500).reduce((acc, e) => acc+e) / 199;
            sandbox.setUniform("u_bass", bass / 255);
            sandbox.setUniform("u_mid", mid / 255);
            sandbox.setUniform("u_high", high / 255);
            sandbox.setUniform("u_distort", audioElement.currentTime % 20 > 15 ? 1 : 0);
            if (audioElement.currentTime && audioElement.duration) {
                sandbox.setUniform("u_tod", 1 - (audioElement.currentTime / audioElement.duration));
            }

            // Start animation
            if (isPlaying && ballSpeed < ballSpeedNormal) {
                console.log("ey");
                ballSpeed += ballAcceleration;
                if (ballSpeed > ballSpeedNormal) {
                    ballSpeed = ballSpeedNormal;
                }
            }

            if (isPlaying && !isDistorting && ballSpeed > ballSpeedNormal) {
                ballSpeed = ballSpeedNormal;
            }

            // Distortion animation
            if (audioElement.currentTime % 20 > 13) {
                ballSpeed = ballSpeedFast;
                isDistorting = true;
                sandbox.setUniform("u_distort", 1);
            } else {
                isDistorting = false;
            }

            sandbox.setUniform("u_ballSpeed", ballSpeed);
            window.requestAnimationFrame(update);

            let ms = timestamp - oldTime;
            let fps = Math.ceil(1/(ms/1000))
            document.getElementById("fps").innerHTML = fps;

            oldTime = timestamp;
        }

        window.requestAnimationFrame(update);
    </script>
</body>
</html>
