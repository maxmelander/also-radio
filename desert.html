<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>
<head>
  <meta content="utf-8">
  <title>DESERT STORM BRO</title>
  <style type="text/css">
          body {
            margin: 0;
          }

          #canvas {
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
          }
  </style>
</head>
<body>
  <canvas id="canvas" />

  <script type="text/javascript" src=
  "https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
  </script>
  <script type="glsl" id="FSHADER_SOURCE">
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;

    const vec2 _LargeWaveDetail = vec2(0.25, 0.63) ;
    const vec3 _LargeWavePowStre = vec3(0.6, 2.96, -2.08) ;
    const vec3 _LargeWaveOffset = vec3(-3.25, 4.41, -11.64) ;

    vec3 _CameraPosition = vec3(1.0, 2.2, 19.6);

    float smin( float a, float b, float k )
    {
        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
        return mix( b, a, h ) - k*h*(1.0-h);
    }

    float sdLargeWaves( in vec3 pos )
    {
        float distZ = abs(pos.z - _CameraPosition.z);
        float distX = abs(pos.x - _CameraPosition.x);
        float dist = (distZ ) + (distX * 0.1);
        dist = dist * dist * 0.01;

        float largeWaves = (sin(_LargeWaveOffset.z + pos.z * _LargeWaveDetail.y + pos.z * 0.02) * sin((_LargeWaveOffset.x + dist) + (pos.x * _LargeWaveDetail.x)) * 0.5) + 0.5;

        largeWaves = -_LargeWaveOffset.y + pow( largeWaves, _LargeWavePowStre.x) *  _LargeWavePowStre.y;

        largeWaves = smin(largeWaves, _LargeWavePowStre.z, 0.2);
        largeWaves = (largeWaves - dist);

        float plane = pos.y + 1.9;

        return plane + largeWaves;
    }


    float map(in vec3 pos) {
        float d1 = length(pos) -5.25;
        float d2 = sdLargeWaves(pos);

        return min(d1, d2);
    }

    vec3 calcNormal(in vec3 pos) {
        vec2 e = vec2(0.0001, 0.0);
        return normalize( vec3( map(pos+e.xyy)-map(pos-e.xyy),
                                map(pos+e.yxy)-map(pos-e.yxy),
                                map(pos+e.yyx)-map(pos-e.yyx)));
    }

    float castRay(in vec3 ro, vec3 rd) {
        float t = 0.0;
        for (int i = 0; i < 100; i++) {
            vec3 pos = ro + t*rd;

            float h = map(pos);

            if (h < 0.001) {
                break;
            }

            t += h;

            if (t > 20.0) {
                break;
            }
        }

        if (t > 20.0) {
            t=-1.0;
        }

        return t;
    }

    void main() {
        vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

        float an = 0.1 * u_time;

        // Camera target
        vec3 ta = vec3(0., 0., 0.);

        _CameraPosition.x += sin(u_time);
        // Ray origin
        vec3 ro = ta + _CameraPosition;

        // Camera vectors
        vec3 ww = normalize(ta - ro);
        vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));
        vec3 vv = normalize(cross(uu,ww));

        // Ray direction
        float fov = 1.0;
        vec3 rd = normalize(p.x * uu + p.y * vv + fov * ww);

        // Color
        vec3 col = vec3(0.4, 0.75, 1.0) - 0.7*rd.y;
        col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y));

        // Ray marching
        float t = castRay(ro, rd);
        if (t > 0.0) {
            vec3 pos = ro + t*rd;
            vec3 nor = calcNormal(pos);

            vec3 mate = vec3(0.18);

            vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));

            float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);
            float sun_sha = step(castRay(pos + nor*0.001, sun_dir), 0.0);
            float sky_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);

            float bounce_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);

            col = mate * vec3(7.0, 5.0, 3.0) * sun_dif * sun_sha;
            col += mate * vec3(0.5, 0.8, 0.9) * sky_dif;
            col += mate * vec3(0.7, 0.3, 0.2) * bounce_dif;
        }

        col = pow( col, vec3(0.4545) );

        gl_FragColor = vec4(col, 1.0); // return reddish-purple
    }
  </script>

  <script type="text/javascript">
    const fs = document.getElementById("FSHADER_SOURCE").textContent;
    const canvas = document.querySelector("#canvas");
    const sandbox = new GlslCanvas(canvas);
    sandbox.load(fs);
  </script>
</body>
</html>
