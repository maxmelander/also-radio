<!DOCTYPE html>
<html>
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>DESERT STORM BRO</title>
    <style type="text/css">
          body {
            margin: 0;
          }

          #canvas {
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
          }
    </style>
</head>
<body>
    <canvas id="canvas" />
    <script type="text/javascript" src=
    "https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js">
    </script>
    <script type="glsl" id="FSHADER_SOURCE">
        precision highp float;
        uniform float u_time;
        uniform vec2 u_resolution;

        vec3 _CameraPosition = vec3(0.0, 0.6, 3.0);

        /* COLORS */
        vec3 _ShadowColor = vec3(0., 0., 0.0);
        vec3 _SunColor = vec3(1., 1., 1.);
        vec3 _BounceColor = vec3(0.81, 0.002, 0.002);
        vec3 _RimColor = vec3(12.9, 11.6, 10.1);
        vec3 _OceanColor = vec3(12.9, 11.6, 10.1);
        vec3 _GlitterColor = vec3(0.8, 0.3, 0.7);

        vec3 _SandColor = vec3(0.78, 0.36, 0.16);

        /* SIMPLEX NOISE */
// Simplex 2D noise
//
vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

float snoise(vec2 v){
  const vec4 C = vec4(0.211324865405187, 0.366025403784439,
           -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);
  vec2 i1;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod(i, 289.0);
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
  + i.x + vec3(0.0, i1.x, 1.0 ));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;
  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}



        float smoothCurve( float x ) {
            return x * x *( 3.0 - 2.0 * x );
        }

        float triangleWave( float x ) {
            return abs( fract( x + 0.5 ) * 2.0 - 1.0 );
        }

        float smoothTriangleWave( float x ) {
            return smoothCurve( triangleWave( x ) );
        } 

        float smin( float a, float b, float k )
        {
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            return mix( b, a, h ) - k*h*(1.0-h);
        }

        float sdPlane( in vec3 pos )
        {

            float fh = -1.0 + 0.9 * (smoothTriangleWave(-0.2 + (0.1*pos.x)) + smoothTriangleWave(0.06*pos.z));
            fh += pow(fh, 1.7);

            float hf = smoothTriangleWave(2.6*(pos.z + 0.03*smoothTriangleWave((pos.x + (u_time * 0.8)) * 2.6))); //+ smoothTriangleWave(20.*pos.y);

            float hf2 = smoothTriangleWave(2.*pos.x + (u_time * 1.));

            float d = pos.y - (fh + (0.02* hf * (clamp(-pos.y + 0.2, 0., 1.))) + (0.002 * hf2 * (pos.y)));

            //return pos.y - fh + (0.02 * hf * (clamp(-pos.y + 0.2, 0., 1.)));

            return d;
        }

        float sdSphere( in vec3 pos, in float radius ) {

            float z = -2.0 + u_time;
            float y = 0.0 + ((1.0 + smoothTriangleWave(u_time * 0.1)) * 1.0);
            vec3 cen = vec3(0.0, y, z);

            return length(pos - cen) - radius;
        }

        float sdCone( in vec3 p, in vec2 c, in float h ) {
            float y = 2.0;

            vec3 po = p;
            float q = length(p.xz);
            return max(dot(c.xy, vec2( q, p.y )), -h-p.y);
        }


        vec2 map(in vec3 pos) {
            float d = -1.0;

            float d1 = sdSphere(pos, 1.);

            float d2 = sdPlane(pos);

            d = smin(d1, d2, 0.5);

            if (d1 < d2) {
                return vec2(d, 2.0);
            } else {
                return vec2(d, 1.0);
            }
        }

        vec3 calcNormal(in vec3 pos) {
            vec2 e = vec2(0.0001, 0.0);
            return normalize( vec3( map(pos+e.xyy).x-map(pos-e.xyy).x,
                                    map(pos+e.yxy).x-map(pos-e.yxy).x,
                                    map(pos+e.yyx).x-map(pos-e.yyx).x));
        }

        vec2 textureMapping(in vec3 pos) {
            return pos.xz*vec2(0.03,0.07);
        }

        vec2 castRay(in vec3 ro, vec3 rd) {
            vec2 res = vec2(-1.0, -1.0);
            float tmin = 0.5;
            float tmax = 20.0;

            float t = tmin;

            for (int i = 0; i < 512; i++) {
                vec2 h = map(ro+rd*t);
                if (abs(h.x) < 0.001) {
                    res = vec2(t, h.y);
                    break;
                }
                t += h.x;

                if (t>tmax) {
                    break;
                }
                
            }

            return res;
        }

        float castShadow(in vec3 ro, vec3 rd) {
            float res = 1.0;

            float t = 0.001;
            for (int i = 0; i < 100; i++) {
                vec3 pos = ro + t*rd;
                float h = map(pos).x;

                res = min( res, 16.0*h / t );

                if ( h < 0.0001 ) break;

                t += h;

                if (t > 20.0) break;
            }

            return res;
        }


        vec3 nlerp(vec3 n1, vec3 n2, float t){
            return normalize(mix(n1, n2, t));
        }


        float diffuse(vec3 n, vec3 l) {
            n.y *= 0.3;
            float nDotL = clamp(4. * dot(n, l), 0.0, 1.0);
            return nDotL;
        }

        float rim(vec3 n, vec3 v) {
            float rim = 1.0 - clamp(dot(n, v), 0.0, 1.0);
            rim = clamp(pow(rim, 70.3) * 0.9, 0.0, 1.0);
            return rim;
        }

        float oceanSpecular(vec3 n, vec3 l, vec3 v) {
            // Blinn-Phong
            vec3 h = normalize(v + l); // Half direction
            float NdotH = max(0., dot(n, h));
            float specular = pow(NdotH, 700.0) * 2.7;
            return specular;
        }

        float glitterSpecular(vec2 uv, vec3 l, vec3 v) {

            vec3 R = reflect(l, vec3(snoise(uv*400.), snoise(uv*500.), snoise(uv*640.)));

            float rDotV = max(0.0, dot(R, v));

            if (rDotV < 0.8) {
                return 0.0;
            }
            return rDotV;
        }

        vec3 sandNormal(vec2 uv, vec3 n) {
            vec3 random = vec3(snoise(uv * 2620.), snoise(uv * 2690.), snoise(uv * 2500.));
            vec3 s = normalize(random);

            vec3 Ns = nlerp(n, s, 0.01);
            return Ns;
        }


        void main() {
            vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

            float an = 0.1 * u_time;

            // Camera target
            vec3 ta = vec3(0., 0.5, 0.);

            _CameraPosition.z += u_time;
            // Ray origin
            vec3 ro = _CameraPosition;

            // Camera vectors
            vec3 ww = normalize(ta - ro);
            vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));
            vec3 vv = normalize(cross(uu,ww));

            // Ray direction
            float fov = 1.6;
            vec3 rd = normalize(p.x * uu + p.y * vv + fov * ww);

            // Color
            vec3 col = vec3(0.18, 0.55, 1.0);
            col = mix(col, vec3(0.95, 0.95, 0.9), exp(-10.0*rd.y));

            // Ray marching
            vec2 tm = castRay(ro, rd);
            if (tm.y > 0.0) {
                float t = tm.x;
                vec3 pos = ro + t*rd;
                vec3 nor = calcNormal(pos);

                vec2 uv = fract(textureMapping(pos) * 4.);

                vec3 sand_nor = sandNormal(uv, nor);

                vec3 sun_dir = normalize(vec3(-1.8, 5.6, -3.2));


                vec3 mate = vec3(0.18, 0.16, 0.13);

                if (tm.y > 1.5) {
                    mate = vec3(0.8, 0.1, 0.1);
                }


                float sun_sha = clamp(castShadow(pos+sand_nor*0.01, sun_dir), 0.0 ,1.0);

                float sky_dif = 0.9 * diffuse(sand_nor, vec3(0.0, 1.0, 0.0));

                float bounce_dif = clamp(0.5 + 0.3*dot(sand_nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);

                float sun_dif = diffuse(sand_nor, sun_dir);
                vec3 diffuse_color = _SandColor * mix(_ShadowColor, _SunColor, sun_dif);

                float rim = rim(sand_nor, -rd);
                float oceanSpec = oceanSpecular(sand_nor, sun_dir, -rd);
                float spec = max(rim, oceanSpec);

                //vec3 spec_color = clamp(max(rim_color, ocean_color), 0.0, 1.0);

                col = mate * vec3(6.0, 4.0, 2.0) * sun_dif * sun_sha;
                col += mate * vec3(3.0, 3.0, 2.0) * spec;

                if (tm.y < 1.5) {
                    float glitterSpec = glitterSpecular(uv, sun_dir, -rd) / t;
                    col += (mate * vec3(20., 20., 10.) * glitterSpec * sun_dif) * sun_sha;
                }

                //col = mix(_ShadowColor, (diffuse_color + spec_color + glitter_color), sun_sha);
                col += mate * vec3(0.5, 0.7, 0.8) * sky_dif;
                col += _BounceColor * bounce_dif;

                //col = glitter_color;
            }

            col = pow( col, vec3(0.4545) );

            gl_FragColor = vec4(col, 1.0); // return reddish-purple
        }
    </script>

    <script type="text/javascript">
        const fs = document.getElementById("FSHADER_SOURCE").textContent;
        const canvas = document.querySelector("#canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const sandbox = new GlslCanvas(canvas);
        sandbox.load(fs);
    </script>
</body>
</html>
